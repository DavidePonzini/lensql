{
    "components": {
        "navbar": {
            "nav": {
                "home": "Home",
                "profile": "Profilo",
                "view_profile": "Visualizza Profilo",
                "learning": "Statistiche di Apprendimento",
                "datasets": "Dataset",
                "explore_sql": "Esplora SQL",
                "admin": "Admin",
                "login": "Accedi",
                "register": "Registrati",
                "logout": "Disconnetti",
                "loading": "Caricamento...",
                "unknown": "Sconosciuto",
                "username_tooltip": "Il tuo nome utente",
                "admin_tooltip": "Amministratore"
            },
            "language": {
                "label": "Lingua",
                "en": "EN",
                "it": "IT"
            },
            "gamification_stats": {
                "level": "Livello",
                "xp": "Punti esperienza",
                "coins": "LensCoins"
            }
        },
        "alert": {
            "under_development": "üöß Questa sezione √® in fase di sviluppo."
        },
        "notifications": {
            "badge": {
                "title": "üèÜ Obiettivo Raggiunto!",
                "exp": "{{count}} EXP",
                "coins": "{{count}} LensCoins"
            },
            "reward": {
                "coin_singular": "LensCoin",
                "coin_plural": "LensCoins",
                "exp": "{{count}} EXP"
            }
        },
        "buttons": {
            "button": {
                "locked_tooltip": "Questa azione √® bloccata",
                "free": "Gratis"
            },
            "modal": {
                "close": "Chiudi"
            },
            "dataset": {
                "title": "Dataset",
                "loading": "Caricamento..."
            }
        },
        "footer": {
            "developed_by": "Sviluppato da Davide Ponzini.",
            "license": "Licenza Pubblica Generale GNU",
            "contact": "Contatta",
            "social": {
                "website": "Sito Web",
                "github": "GitHub",
                "email": "Email"
            }
        },
        "assignmentList": {
            "title": "Assegna a",
            "select_all": "Seleziona tutti"
        },
        "learningStats": {
            "learning": {
                "queries_teacher": "Esploriamo le query dei tuoi studenti",
                "queries_student": "Esploriamo le tue query",
                "messages": "Trasformare le domande in progresso",
                "errors": "Dove le cose si sono complicate"
            },
            "errors": {
                "empty": {
                    "student": "Non hai ancora commesso errori. Quando lo farai, ti mostreremo i tipi di errori e come sono cambiati nel tempo.",
                    "teacher": "I tuoi studenti non hanno ancora commesso errori. Quando lo faranno, ti mostreremo i tipi di errori e come sono cambiati nel tempo."
                },
                "kind_title": "Che tipo di problemi sono emersi?",
                "kind_subtitle": {
                    "student": "I tuoi errori rientrano in alcune categorie principali ‚Äî ecco una panoramica.",
                    "teacher": "Gli errori dei tuoi studenti rientrano in alcune categorie principali ‚Äî ecco una panoramica."
                },
                "kind_body": {
                    "student": "In fase di sviluppo! Questa sezione classificher√† i tuoi errori in sintattici, semantici, logici e complicazioni.",
                    "teacher": "In fase di sviluppo! Questa sezione classificher√† gli errori dei tuoi studenti in sintattici, semantici, logici e complicazioni."
                },
                "common_title": "Errori pi√π comuni",
                "common_subtitle": {
                    "student": "Ecco i pattern di errore pi√π frequenti rilevati nelle tue query.",
                    "teacher": "Ecco i pattern di errore pi√π frequenti rilevati nelle query dei tuoi studenti."
                },
                "common_body": {
                    "student": "In fase di sviluppo! Questa sezione mostrer√† i pattern di errore pi√π frequenti nelle tue query.",
                    "teacher": "In fase di sviluppo! Questa sezione mostrer√† i pattern di errore pi√π frequenti nelle query dei tuoi studenti."
                },
                "timeline_title": {
                    "student": "Come sono cambiati i tuoi errori nel tempo",
                    "teacher": "Come sono cambiati gli errori dei tuoi studenti nel tempo"
                },
                "timeline_subtitle": {
                    "student": "Guarda se stai commettendo meno errori man mano che progredisci.",
                    "teacher": "Guarda se i tuoi studenti stanno commettendo meno errori man mano che progrediscono."
                },
                "count_label": "{{count}} errori",
                "example_label": "Esempio",
                "correction_label": "Correzione",
                "explanation_label": "Spiegazione"
            },
            "messages": {
                "empty": {
                    "student": "Non hai ancora chiesto aiuto. Quando lo farai, ti mostreremo quante volte hai chiesto spiegazioni e quanto hai compreso le risposte.",
                    "teacher": "I tuoi studenti non hanno ancora chiesto aiuto. Quando lo faranno, ti mostreremo quante volte hanno chiesto spiegazioni e quanto hanno compreso le risposte."
                },
                "title_help": {
                    "student": "Tu hai chiesto, Lens ha spiegato",
                    "teacher": "I tuoi studenti hanno chiesto, Lens ha spiegato"
                },
                "subtitle_help": {
                    "student": "Bloccato o curioso? Ecco quando hai chiesto spiegazioni o chiarimenti sulle query.",
                    "teacher": "Bloccati o curiosi? Ecco quando i tuoi studenti hanno chiesto spiegazioni o chiarimenti sulle loro query."
                },
                "list_title": {
                    "student": "Quando hai chiesto aiuto:",
                    "teacher": "Quando i tuoi studenti hanno chiesto aiuto:"
                },
                "list_labels": {
                    "total": "Richieste totali",
                    "select": "Sulle query SELECT"
                },
                "chart_title": {
                    "student": "Cosa stavi cercando:",
                    "teacher": "Cosa stavano cercando i tuoi studenti:"
                },
                "understanding_results": "Comprendere risultati",
                "understanding_errors": "Comprendere errori",
                "title_feedback": {
                    "student": "Hai valutato le risposte",
                    "teacher": "I tuoi studenti hanno valutato le risposte"
                },
                "subtitle_feedback": {
                    "student": "Hai dato un voto positivo o negativo alle spiegazioni ‚Äî questo ci aiuta a migliorare.",
                    "teacher": "I tuoi studenti hanno dato un voto positivo o negativo alle spiegazioni ‚Äî questo ci aiuta a migliorare."
                },
                "feedback_given": "Feedback fornito",
                "feedback_not_given": "Nessun feedback"
            },
            "queries": {
                "empty": {
                    "student": "Non hai ancora eseguito query. Quando lo farai, ti mostreremo quante query hai provato, quante hanno funzionato e quali tipi hai usato.",
                    "teacher": "I tuoi studenti non hanno ancora eseguito query. Quando lo faranno, ti mostreremo quante ne hanno provate, quante hanno funzionato e quali tipi hanno usato."
                },
                "title": {
                    "student": "Il tuo percorso SQL",
                    "teacher": "Il percorso SQL dei tuoi studenti"
                },
                "stats": {
                    "distinct": "Query distinte provate",
                    "total": "Query totali eseguite",
                    "note": "Ogni tentativo conta ‚Äî anche i ripetuti fanno parte dell‚Äôapprendimento."
                },
                "success_title": "Quanto spesso ha funzionato",
                "select_label": "Query SELECT",
                "all_label": "Tutte le query",
                "chart_title": {
                    "student": "Che tipo di query stai eseguendo?",
                    "teacher": "Che tipo di query stanno eseguendo i tuoi studenti?"
                },
                "chart_subtitle": {
                    "student": "Ecco i vari comandi SQL che hai usato e come sono andati.",
                    "teacher": "Ecco i vari comandi SQL che i tuoi studenti hanno usato e come sono andati."
                },
                "chart_empty": {
                    "student": "Nessuna query eseguita. Inizia a esplorare SQL!",
                    "teacher": "Nessuna query eseguita. Aspetta che i tuoi studenti inizino a esplorare SQL!"
                },
                "success": "Corrette",
                "fail": "Errate"
            }
        }
    },
    "pages": {
        "admin": {
            "title": "Pagina di amministrazione",
            "empty": "Nessun contenuto disponibile"
        },
        "datasetes": {
            "dataset": {
                "new": "Nuovo Dataset",
                "save": "Salva"
            },
            "dataset_card": {
                "exercises": "Esercizi",
                "queries": "Query eseguite",
                "badge_teacher": "Docente",
                "join_code": "Codice di iscrizione",
                "students": "Studenti",
                "open": "Apri",
                "leave": "Lascia",
                "confirm_leave": "Sei sicuro di voler abbandonare questo dataset?",
                "my_learning_analytics": "Le mie statistiche di apprendimento",
                "student_learning_analytics": "Statistiche di apprendimento degli studenti",
                "set_teachers": "Imposta Docenti",
                "participants": "Partecipanti"
            },
            "dataset_list": {
                "title": "I miei dataset",
                "empty": "Nessun dataset trovato. Unisciti a un dataset o creane uno nuovo.",
                "new_dataset_suggestion": "Se vuoi eseguire una query non assegnata da un docente, crea un nuovo dataset.",
                "join": "Unisciti a un dataset",
                "join_prompt": "Inserisci il codice del dataset:"
            },
            "dataset_mask": {
                "title_label": "Titolo",
                "dataset_label": "Dataset (Opzionale)",
                "tips_title": "Suggerimenti",
                "tips": [
                    "Includi l'intero script in un blocco <code>BEGIN; ... COMMIT;</code>",
                    "Inizia lo script con <code>DROP SCHEMA IF EXISTS schema_name CASCADE;</code>",
                    "Usa un <code>search_path</code> unico per ogni dataset",
                    "Raggruppa le inserzioni in un unico comando <code>INSERT INTO</code> per ogni tabella per migliorare le prestazioni"
                ],
                "title_placeholder": "Titolo descrittivo del dataset",
                "dataset_str_placeholder": "BEGIN;\n\nDROP SCHEMA IF EXISTS <schema_name> CASCADE;\nCREATE SCHEMA <schema_name>;\nSET search_path TO <schema_name>;\n\nCREATE TABLE ...;\n\nINSERT INTO ...;\n\nCOMMIT;"
            },
            "dataset_update": {
                "modal_title": "Modifica Dataset",
                "button_text": "Modifica",
                "save": "Salva"
            },
            "exercise_add": {
                "title": "Aggiungi Esercizio",
                "button_text": "Nuovo Esercizio",
                "save": "Salva"
            },
            "exercise": {
                "hidden": "Nascosto",
                "solved": "Risolto",
                "generated": "Generato dall'IA",
                "objectives": "Obiettivi di Apprendimento",
                "archive": "Archivia",
                "unarchive": "Annulla Archiviazione",
                "open": "Apri",
                "analytics": "Statistiche di Apprendimento",
                "edit": "Modifica",
                "objectives_set": "Imposta Obiettivi",
                "hide": "Nascondi",
                "show": "Rendi Visibile",
                "delete": "Elimina",
                "delete_confirm": "Sei sicuro di voler eliminare questo esercizio? Questa azione non pu√≤ essere annullata."
            },
            "exercise_list": {
                "title": "Esercizi",
                "none": "Nessun esercizio",
                "archived": "Archiviati",
                "archived_none": "Nessun esercizio archiviato"
            },
            "exercise_mask": {
                "title": "Titolo",
                "request": "Richiesta",
                "answer_optional": "Risposta (facoltativa)",
                "add_answer": "Aggiungi risposta",
                "remove_answer": "Rimuovi risposta",
                "title_placeholder": "Titolo breve e descrittivo per l'esercizio",
                "request_placeholder": "Cosa dovrebbe fare la query?",
                "search_path_label": "Percorso di ricerca della soluzione"
            },
            "exercise_update": {
                "title": "Modifica esercizio",
                "button": "Modifica",
                "save": "Salva"
            },
            "learning_objectives": {
                "title": "Imposta obiettivi",
                "button": "Imposta obiettivi",
                "list_title": "Imposta obiettivi di apprendimento"
            }
        },
        "profile": {
            "learning": {
                "title": "Bentornato, {{username}}!",
                "subtitle": "Ecco una panoramica dei tuoi progressi in SQL"
            },
            "profile": {
                "welcome": "Bentornato, {{username}}!",
                "progress": "Ecco una panoramica dei tuoi progressi",
                "contact_support": "Contatta il supporto",
                "level": {
                    "title": "Livello Attuale",
                    "exp": "EXP: {{xp}} / {{xpToNext}}",
                    "tip": "Ottieni pi√π EXP studiando SQL:",
                    "earn_exp": "Come guadagnare EXP"
                },
                "coins": {
                    "title": "LensCoins",
                    "available": "{{coins}} monete disponibili",
                    "tip": "Usa i LensCoins per interagire con Lens:",
                    "earn_coins": "Come guadagnare LensCoins"
                },
                "achievements": {
                    "title": "Obiettivi",
                    "text": "Hai ottenuto i seguenti obiettivi:"
                },
                "settings": "Impostazioni",
                "change_password": {
                    "title": "Cambia Password",
                    "current_password_label": "Password Attuale",
                    "new_password_label": "Nuova Password",
                    "confirm_new_password_label": "Conferma Nuova Password",
                    "submit_button": "Aggiorna Password",
                    "current_required": "Inserisci la tua password attuale.",
                    "confirm_required": "Conferma la tua nuova password.",
                    "password_mismatch_alert": "Le password non corrispondono.",
                    "success_alert": "La tua password √® stata aggiornata con successo!",
                    "error_generic": "Si √® verificato un errore imprevisto durante l'aggiornamento della password."
                }
            }
        },
        "about": {
            "title": "Informazioni su LensQL",
            "p1": "LensQL √® una piattaforma interattiva che aiuta gli studenti a imparare SQL attraverso esercitazioni guidate, feedback personalizzati e un percorso di apprendimento gamificato. Progettata per studenti e insegnanti, favorisce una comprensione pi√π profonda dei database relazionali, concentrandosi sul ragionamento dietro le query, non solo sulla loro correttezza.",
            "p2": "Anzich√© fornire soluzioni immediate, LensQL incoraggia l‚Äôesplorazione attiva. L‚Äôassistente AI, Lens, aiuta gli studenti a riflettere sugli errori, affinare la logica e migliorare le competenze con ogni tentativo. Gli insegnanti, nel frattempo, ottengono una panoramica su come apprendono gli studenti, dove incontrano difficolt√† e come supportarli al meglio.",
            "p3": "Che tu stia eseguendo la tua prima query o perfezionando join complessi, LensQL trasforma ogni errore in un‚Äôopportunit√† di apprendimento.",
            "moreTitle": "üîç Vuoi saperne di pi√π?",
            "moreIntro": "LensQL √® sviluppato come parte di una ricerca in corso presso l‚ÄôUniversit√† di Genova. Se sei curioso di approfondire gli aspetti accademici o tecnici, ecco alcune pubblicazioni che ne esplorano i fondamenti:",
            "paper1": "Analyzing Common Student Errors in SQL Query Formulation to Enhance Learning Support",
            "paper1Desc": "Uno studio su larga scala sugli errori SQL degli studenti e le differenze nei diversi contesti educativi.",
            "paper2": "Enhancing SQL Learning through Generative AI and Student Error Analysis",
            "paper2Desc": "Un framework per feedback AI-driven, tracciamento degli errori e generazione personalizzata di esercizi nell'insegnamento di SQL.",
            "cta": "Prova LensQL"
        },
        "login": {
            "title": "Accedi al tuo account",
            "subtitle": "Non hai un account? Registrati qui",
            "username": "Nome utente",
            "usernamePlaceholder": "Nome utente",
            "usernameRequired": "Inserisci un nome utente.",
            "password": "Password",
            "passwordPlaceholder": "Password",
            "passwordRequired": "Inserisci una password.",
            "show": "Mostra password",
            "hide": "Nascondi password",
            "submit": "Accedi",
            "errorEmptyFields": "Compila entrambi i campi.",
            "errorServer": "Impossibile connettersi al server.",
            "errorLoginFailed": "Accesso non riuscito"
        },
        "register": {
            "title": "Registrati con un nuovo account",
            "subtitle": "Hai gi√† un account? Accedi qui",
            "success": "Registrazione completata! Ora puoi accedere con il tuo nuovo account.",
            "gotoLogin": "Vai al Login",
            "submit": "Registrati",
            "username": "Nome utente",
            "usernamePlaceholder": "Nome utente",
            "usernameRequired": "Inserisci un nome utente.",
            "password": "Password",
            "passwordPlaceholder": "Password",
            "passwordRequired": "Inserisci una password.",
            "passwordLength": "La password deve contenere almeno 8 caratteri.",
            "passwordUpper": "La password deve contenere almeno una lettera maiuscola.",
            "passwordLower": "La password deve contenere almeno una lettera minuscola.",
            "passwordDigit": "La password deve contenere almeno un numero.",
            "passwordSpecial": "La password deve contenere almeno un carattere speciale.",
            "show": "Mostra password",
            "hide": "Nascondi password",
            "email": "Email (opzionale)",
            "emailPlaceholder": "Email",
            "emailRequired": "Inserisci un indirizzo email.",
            "emailInvalid": "Inserisci un indirizzo email valido.",
            "school": "Scuola",
            "schoolPlaceholder": "Scuola",
            "schoolRequired": "Inserisci la tua scuola.",
            "errorServer": "Impossibile connettersi al server.",
            "errorGeneric": "Registrazione fallita"
        },
        "exercises": {
            "buttons": {
                "category": {
                    "database": "Database",
                    "exercise": "Esercizio",
                    "query": "Query"
                },
                "database": {
                    "show_search_path": "Mostra Search Path",
                    "list_tables": "Elenca Tabelle",
                    "list_tables_current": "Schema Corrente",
                    "list_tables_all": "Tutti gli Schemi",
                    "list_schemas": "Elenca Schemi",
                    "list_constraints": "Elenca Vincoli"
                },
                "exercise": {
                    "dataset": "Dataset",
                    "create": "Crea",
                    "check_result": "Verifica Risultato",
                    "no_solution": "Soluzione non disponibile",
                    "attempt_singular": "{{count}} tentativo",
                    "attempt_plural": "{{count}} tentativi",
                    "dataset_error": "Errore durante la creazione del dataset. Controlla la console per i dettagli.\nSe il dataset √® molto grande, prova a eseguire i comandi manualmente in piccoli blocchi."
                },
                "query": {
                    "execute": "Esegui",
                    "clear_output": "Pulisci output",
                    "query_too_large": "Query troppo lunga. Prova a dividerla in parti pi√π piccole. Devi rimuovere almeno {{excess}} caratteri."
                }
            },
            "exercises": {
                "loading": "Caricamento..."
            },
            "message": {
                "feedback_invite": "Puoi guadagnare LensCoins fornendo feedback su questo messaggio"
            },
            "messageBox": {
                "assistant_name": "Lens",
                "user_name": "Tu"
            },
            "query": {
                "back_to_top": "Torna in cima"
            },
            "query_result": {
                "builtin": "Funzione incorporata di LensQL",
                "user": "Query utente"
            },
            "chat": {
                "initial_prompt": "Vuoi chiedermi qualcosa su questo risultato?",
                "followup_prompt": "Vuoi chiedere qualcos'altro?",
                "thinking": "Lens sta pensando...",
                "buttons": {
                    "describe": "Cosa fa la mia query?",
                    "explain": "Cosa fa la mia query in dettaglio?",
                    "explain_error": "Cosa significa questo errore?",
                    "example": "Cosa pu√≤ causare questo errore?",
                    "locate": "Dove si trova il problema nella mia query?",
                    "fix": "Come posso correggere questo errore?",
                    "detect_errors": "La mia query ha degli errori?"
                },
                "prompts": {
                    "describe": "Cosa fa la mia query? Fornisci un riassunto conciso del suo comportamento.",
                    "explain": "Cosa fa la mia query in dettaglio? Spiega cosa fa ogni clausola della mia query.",
                    "explain_error": "Cosa significa questo errore? Spiega il messaggio di errore in termini semplici.",
                    "example": "Cosa pu√≤ causare questo errore? Fornisci una query di esempio semplificata che potrebbe portare a questo errore.",
                    "locate": "Dove si trova il problema nella mia query? Mostrami quale parte della query sta causando questo errore.",
                    "fix": "Come posso correggere questo errore? Suggerisci una possibile correzione per questo errore.",
                    "detect_errors": "La mia query ha degli errori? Analizza la mia query e identifica eventuali problemi."
                }
            }
        },
        "home": {
            "hero": {
                "title": "Impara SQL Sbagliando ‚Äì Con LensQL",
                "subtitle": "Scopri SQL. Impara dagli errori. Cresci con Lens.",
                "description": "LensQL √® una piattaforma di apprendimento SQL potenziata dall'IA che trasforma gli errori degli studenti in momenti di apprendimento personalizzati e interattivi.",
                "cta_register": "Crea o Unisciti a un Dataset",
                "cta_about": "Come Funziona LensQL"
            },
            "what_is": {
                "title": "Cos'√® LensQL?",
                "subtitle": "Un modo pi√π intelligente per imparare SQL ‚Äî basato sui tuoi errori, potenziato dall'IA.",
                "features": {
                    "ai_tutor": "ü§ñ <strong>Tutor basato su IA</strong> che aiuta gli studenti a fare debug delle query e a pensare criticamente",
                    "error_pedagogy": "üß† <strong>Pedagogia basata sugli errori</strong>: impara da errori di sintassi, logica e semantica",
                    "personalization": "üéØ <strong>Compiti e dashboard personalizzati</strong> basati sui progressi reali"
                },
                "quote": "‚ÄúOltre il 95% delle query vengono eseguite fuori dall‚Äôorario di lezione. LensQL supporta l‚Äôapprendimento riflessivo e autonomo.‚Äù"
            },
            "how_it_works": {
                "title": "Come Funziona LensQL",
                "steps": [
                    "üßë‚Äçüè´ Gli insegnanti creano esercizi, se vogliono, mirati a errori comuni",
                    "üéì Gli studenti risolvono query con l‚Äôaiuto di Lens ‚Äî niente risposte dirette, solo guida interattiva",
                    "üìä Il sistema analizza ogni query per rilevare errori e tracciare i progressi",
                    "üõ†Ô∏è Esercizi personalizzati vengono generati automaticamente per colmare lacune specifiche",
                    "üìà Dashboard interattive mostrano come evolve la comprensione nel tempo"
                ],
                "cta_research": "Guarda la ricerca alla base"
            },
            "meet_lens": {
                "title": "Conosci Lens: il tuo compagno SQL",
                "description": "Lens era un esploratore di antichi dati ‚Äî finch√© una misteriosa query SQL non l'ha trasformato in un'IA. Ora guida gli studenti attraverso i JOIN e i WHERE con curiosit√†, chiarezza e gentilezza.",
                "features": {
                    "explain_errors": "‚ùì <strong>Spiega gli errori</strong> in modo semplice",
                    "locate_mistakes": "üìå <strong>Aiuta a localizzare gli errori</strong> nella tua query",
                    "show_examples": "üß™ <strong>Mostra esempi</strong> di query simili",
                    "describe_query": "üß≠ <strong>Descrive il comportamento della query</strong> per riflettere su intento e risultato",
                    "suggest_after_reflection": "‚ö†Ô∏è <strong>Offre suggerimenti solo dopo la riflessione</strong> ‚Äî per favorire un apprendimento autentico"
                }
            },
            "why_errors": {
                "title": "Perch√© Imparare dagli Errori?",
                "students": {
                    "title": "Per gli Studenti",
                    "items": [
                        "üß† <strong>Capire il perch√©</strong>, non solo il come",
                        "üîÅ <strong>Migliorare con prove e tentativi</strong>",
                        "üöÄ <strong>Sviluppare abilit√† di debugging e metacognitive</strong>"
                    ]
                },
                "teachers": {
                    "title": "Per i Docenti",
                    "items": [
                        "üìä <strong>Individuare incomprensioni in anticipo</strong>",
                        "üß© <strong>Osservare percorsi di apprendimento</strong>, non solo risposte corrette",
                        "üõ†Ô∏è <strong>Adattare il supporto</strong> con dati concreti"
                    ]
                }
            },
            "gamification": {
                "title": "üéÆ Apprendimento Gamificato che Premia Sforzo e Intuizione",
                "description": "Imparare SQL dovrebbe essere gratificante ‚Äî e anche un po‚Äô divertente. LensQL usa due sistemi di progressione per motivare gli studenti a esercitarsi, riflettere e crescere.",
                "xp": {
                    "title": "üîπ XP e Livelli ‚Äî Progredisci con la Pratica",
                    "description": "Guadagna esperienza scrivendo ed eseguendo query. Salire di livello mostra i tuoi progressi e premia la costanza ‚Äî non solo le risposte giuste.",
                    "quote": "‚ÄúNon devi essere perfetto ‚Äî solo costante. Pi√π sperimenti, pi√π impari.‚Äù"
                },
                "coins": {
                    "title": "ü™ô LensCoins ‚Äî Usali con Cura, Rifletti a Fondo",
                    "description": "I LensCoins si guadagnano con l‚Äôimpegno e si spendono quando chiedi aiuto a Lens. Ti incoraggiano a provare prima ‚Äî e a riflettere dopo.",
                    "quote": "‚ÄúI LensCoins incentivano la riflessione. Spendili quando sei davvero bloccato ‚Äî e riguadagnali risolvendo e aiutando Lens a migliorare.‚Äù"
                },
                "why": {
                    "title": "üí° Perch√© Funziona",
                    "items": [
                        "üéØ Incentiva <strong>sperimentazione</strong>, non perfezione",
                        "üìà Premia <strong>impegno costante</strong> e apprendimento attivo",
                        "ü§ù Crea un <strong>dialogo</strong> tra studente e assistente IA",
                        "üîÑ Aiuta i docenti a vedere <strong>chi si impegna, non solo chi riesce</strong>"
                    ]
                }
            },
            "dashboard": {
                "title": "üìä Il Tuo Cruscotto di Apprendimento",
                "students": {
                    "title": "Per gli Studenti",
                    "items": [
                        "üìå Tieni traccia di quante query esegui e con quale successo",
                        "üìä Comprendi che tipo di query scrivi e come cambiano nel tempo",
                        "ü§ñ Osserva quando e perch√© interagisci con Lens e come reagisci ai suoi suggerimenti",
                        "üïí Segui i tuoi progressi nel tempo attraverso le query e gli errori"
                    ]
                },
                "teachers": {
                    "title": "Per i Docenti",
                    "items": [
                        "üìä Visualizza metriche aggregate per ogni classe: attivit√†, successo e uso dell‚Äôassistente",
                        "üìÇ Analizza gli errori per categoria: sintattici, semantici, logici o complicazioni",
                        "üïí Tieni traccia dell‚Äôevoluzione nel tempo delle query e degli errori",
                        "üß≠ Adatta la didattica in base a ci√≤ che gli studenti provano, non solo a ci√≤ che riescono"
                    ]
                }
            },
            "demo": {
                "title": "üöÄ Prova LensQL Ora",
                "description": "LensQL richiede registrazione, ma ecco un‚Äôanteprima di come ti aiuta a ragionare sugli errori passo dopo passo.",
                "example_caption": "Esempio: <code>SELECT name FROM students WHERE grade &gt; AVG(grade)</code>",
                "example_note": "Lens identifica un errore di sintassi e lo spiega in modo semplice, senza fornire la risposta."
            },
            "community": {
                "title": "ü§ù Entra nella Community di LensQL",
                "description": "Gi√† utilizzato da <strong>oltre 100 studenti</strong> al di fuori della classe.",
                "teachers": {
                    "title": "‚úÖ Per i Docenti",
                    "items": [
                        "üìö Crea corsi",
                        "üìù Assegna esercizi",
                        "üìä Monitora l'apprendimento della classe"
                    ]
                },
                "students": {
                    "title": "‚úÖ Per gli Studenti",
                    "items": [
                        "üí¨ Ottieni feedback immediato",
                        "üí° Allena il tuo SQL con uno scopo",
                        "üõ†Ô∏è Supera le tue difficolt√†"
                    ]
                }
            },
            "cta": {
                "title": "üí° Imparare SQL non inizia dalle risposte. Inizia dagli errori.",
                "register": "Crea il Tuo Account",
                "about": "Scopri di pi√π"
            }
        }
    },
    "gamification": {
        "actions": {
            "solve_exercises": {
                "label": "Risolvi esercizi",
                "xp": "+1000 XP",
                "coins": "+100 monete"
            },
            "run_queries": {
                "label": "Esegui query",
                "xp": "+5 XP",
                "coins": ""
            },
            "try_unique_queries": {
                "label": "Prova nuove query uniche",
                "xp": "+25 XP per nuova query",
                "coins": ""
            },
            "interact_with_lens": {
                "label": "Interagisci con Lens",
                "xp": "+5 XP",
                "coins": ""
            },
            "feedback_on_lens": {
                "label": "Dai un feedback sull‚Äôaiuto di Lens",
                "xp": "+5 XP",
                "coins": "+10 monete"
            },
            "achievements": {
                "label": "Sblocca obiettivi",
                "xp": "quantit√† variabili",
                "coins": "quantit√† variabili"
            },
            "check_solution": {
                "label": "Controlla se la soluzione √® corretta",
                "xp": "",
                "coins": "da 0 a -5 monete"
            },
            "ask_lens": {
                "label": "Chiedi aiuto a Lens",
                "xp": "",
                "coins": "da -1 a -10 monete"
            },
            "_variable_amounts": "Quantit√† variabili"
        },
        "badges": {
            "locked": "Bloccato",
            "rank": "Grado {{rank}}",
            "create_exercises": {
                "name": "Creatore di Esercizi",
                "description": "Crea esercizi ed esegui query in essi",
                "next": "Esercizi per il prossimo grado",
                "next_locked": "Esercizi per sbloccare",
                "levels": {
                    "1": "Creato il tuo primo esercizio ed eseguito una query in esso",
                    "5": "Creato 5 esercizi ed eseguito una query in ciascuno di essi",
                    "10": "Creato 10 esercizi ed eseguito una query in ciascuno di essi"
                }
            },
            "feedback": {
                "name": "Fornitore di Feedback",
                "description": "Fornisci feedback sull'aiuto di Lens",
                "next": "Feedback per il prossimo grado",
                "next_locked": "Feedback per sbloccare",
                "levels": {
                    "1": "Fornito il tuo primo feedback",
                    "10": "Fornito feedback 10 volte",
                    "50": "Fornito feedback 50 volte"
                }
            },
            "queries_unique": {
                "name": "Interrogatore Curioso",
                "description": "Prova query diverse",
                "next": "Query uniche per il prossimo grado",
                "next_locked": "Query uniche per sbloccare",
                "levels": {
                    "1": "Eseguita la tua prima query",
                    "10": "Eseguite 10 query diverse",
                    "50": "Eseguite 50 query diverse",
                    "100": "Eseguite 100 query diverse",
                    "500": "Eseguite 500 query diverse",
                    "1000": "Eseguite 1000 query diverse",
                    "2500": "Eseguite 2500 query diverse",
                    "5000": "Eseguite 5000 query diverse",
                    "10000": "Eseguite 10000 query diverse"
                }
            },
            "exercise_solutions": {
                "name": "Risolutore di Esercizi",
                "description": "Risolvi esercizi",
                "next": "Esercizi risolti per il prossimo grado",
                "next_locked": "Esercizi risolti per sbloccare",
                "levels": {
                    "1": "Risolto il tuo primo esercizio",
                    "5": "Risolti 5 esercizi",
                    "10": "Risolti 10 esercizi"
                }
            },
            "help_usage": {
                "name": "Conversatore con Lens",
                "description": "Interagisci con Lens",
                "next": "Interazioni per il prossimo grado",
                "next_locked": "Interazioni per sbloccare",
                "levels": {
                    "1": "Interagito con Lens per la prima volta",
                    "10": "Interagito con Lens 10 volte",
                    "50": "Interagito con Lens 50 volte",
                    "100": "Interagito con Lens 100 volte",
                    "500": "Interagito con Lens 500 volte",
                    "1000": "Interagito con Lens 1000 volte"
                }
            },
            "daily_usage": {
                "name": "Apprendista Quotidiano",
                "description": "Esegui una query in giorni diversi",
                "next": "Giorni di attivit√† per il prossimo grado",
                "next_locked": "Giorni di attivit√† per sbloccare",
                "levels": {
                    "5": "Esegui una query in 5 giorni diversi",
                    "14": "Esegui una query in 14 giorni diversi",
                    "30": "Esegui una query in 30 giorni diversi"
                }
            },
            "level_up": {
                "name": "Salitore di Livelli",
                "description": "Salita di livello",
                "next": "Livelli per il prossimo grado",
                "next_locked": "Livelli per sbloccare",
                "levels": {
                    "3": "Raggiunto il livello 3",
                    "5": "Raggiunto il livello 5",
                    "10": "Raggiunto il livello 10"
                }
            },
            "join_dataset": {
                "name": "Esploratore di Dataset",
                "description": "Unisciti ai dataset",
                "next": "Dataset uniti per il prossimo grado",
                "next_locked": "Dataset uniti per sbloccare",
                "levels": {
                    "1": "Unito al tuo primo dataset"
                }
            }
        },
        "levels": {
            "0": "Principiante curioso",
            "1": "Pensatore logico",
            "2": "Apprendista delle query",
            "3": "Cercatore di pattern",
            "4": "Esploratore relazionale",
            "5": "Analista intenzionale",
            "6": "Interprete dei dati",
            "7": "Costruttore di intuizioni",
            "8": "Pensatore strutturato",
            "9": "Architetto delle query"
        }
    },
    "learning_objectives": {
        "Simple Select": {
            "label": "SELECT semplice",
            "description": "Scrivi un'istruzione SELECT semplice per recuperare dati da una sola tabella."
        },
        "Single condition": {
            "label": "Condizione singola",
            "description": "Scrivi query che filtrano i risultati in base a una sola condizione."
        },
        "Distinct": {
            "label": "DISTINCT",
            "description": "Usa la parola chiave DISTINCT per eliminare righe duplicate dai risultati."
        },
        "Aggregate functions": {
            "label": "Funzioni di aggregazione",
            "description": "Usa funzioni come COUNT, SUM, AVG, MIN e MAX per riassumere i dati."
        },
        "Subquery in SELECT": {
            "label": "Subquery in SELECT",
            "description": "Scrivi query che includono sottoquery nella clausola SELECT."
        },
        "Case statements": {
            "label": "Istruzioni CASE",
            "description": "Usa le istruzioni CASE per creare logica condizionale nelle query."
        },
        "String functions": {
            "label": "Funzioni stringa",
            "description": "Applica funzioni stringa per manipolare i dati testuali nelle query."
        },
        "Date functions": {
            "label": "Funzioni di data",
            "description": "Usa funzioni di data per manipolare e formattare dati temporali."
        },
        "Numeric functions": {
            "label": "Funzioni numeriche",
            "description": "Applica funzioni numeriche per effettuare calcoli su dati numerici."
        },
        "Window functions": {
            "label": "Funzioni finestra",
            "description": "Usa le funzioni finestra per calcolare risultati su insiemi di righe correlate."
        },
        "Simple join": {
            "label": "JOIN semplice",
            "description": "Scrivi query che utilizzano un join tra due tabelle per ottenere dati correlati."
        },
        "Self join": {
            "label": "SELF JOIN",
            "description": "Scrivi query che utilizzano un self-join per confrontare righe nella stessa tabella."
        },
        "Left join": {
            "label": "LEFT JOIN",
            "description": "Scrivi query che usano LEFT JOIN per ottenere tutte le righe da una tabella e quelle corrispondenti da un'altra."
        },
        "Right join": {
            "label": "RIGHT JOIN",
            "description": "Scrivi query che usano RIGHT JOIN per ottenere tutte le righe da una tabella e quelle corrispondenti da un'altra."
        },
        "Full outer join": {
            "label": "FULL OUTER JOIN",
            "description": "Usa FULL OUTER JOIN per ottenere tutte le righe dove c'√® una corrispondenza in almeno una tabella."
        },
        "Subquery in FROM": {
            "label": "Subquery in FROM",
            "description": "Usa sottoquery nella clausola FROM per creare tabelle derivate."
        },
        "Multiple conditions": {
            "label": "Condizioni multiple",
            "description": "Usa operatori logici per filtrare i risultati in base a pi√π condizioni."
        },
        "Subquery in WHERE": {
            "label": "Subquery in WHERE",
            "description": "Usa sottoquery nella clausola WHERE per filtrare i risultati in base a dati correlati."
        },
        "Correlated subqueries": {
            "label": "Sottoquery correlate",
            "description": "Scrivi sottoquery che fanno riferimento a colonne della query esterna."
        },
        "Group by": {
            "label": "GROUP BY",
            "description": "Raggruppa i risultati usando GROUP BY per aggregare i dati."
        },
        "Group by with conditions": {
            "label": "Clausola HAVING",
            "description": "Usa la clausola HAVING per filtrare i risultati aggregati."
        },
        "Order by": {
            "label": "ORDER BY",
            "description": "Ordina i risultati delle query usando ORDER BY."
        },
        "Limit and offset": {
            "label": "LIMIT e OFFSET",
            "description": "Usa LIMIT e OFFSET per controllare il numero di righe restituite da una query."
        },
        "Union": {
            "label": "UNION",
            "description": "Combina i risultati di pi√π query usando l'operatore UNION."
        },
        "Intersect": {
            "label": "INTERSECT",
            "description": "Recupera risultati comuni a pi√π query usando INTERSECT."
        },
        "Except": {
            "label": "EXCEPT",
            "description": "Usa EXCEPT per trovare righe in una query che non sono presenti in un'altra."
        }
    },
    "errors": {
        "categories": {
            "syn": {
                "name": "Errori sintattici",
                "description": "Sintassi SQL errata, come parole chiave mancanti, punteggiatura errata o istruzioni malformate."
            },
            "sem": {
                "name": "Errori semantici",
                "description": "Sintassi corretta ma query priva di significato, come restituire sempre un insieme di risultati vuoto."
            },
            "log": {
                "name": "Errori logici",
                "description": "La query viene eseguita senza errori ma produce risultati errati a causa di una logica difettosa o di una comprensione errata dei requisiti."
            },
            "com": {
                "name": "Complicazioni",
                "description": "La query restituisce il risultato corretto ma utilizza metodi inefficienti o costrutti complessi che potrebbero essere semplificati."
            }
        },
        "errors": {
            "1": {
                "name": "Omissione dei nomi di correlazione",
                "description": "Quando si usano pi√π tabelle in una query, una colonna presente in pi√π di una tabella viene referenziata senza specificare a quale tabella appartiene.",
                "example": "SELECT id FROM studenti, insegnanti;",
                "explanation": "Entrambe le tabelle contengono una colonna chiamata 'id'. Senza specificare la tabella, il database non pu√≤ determinare quale 'id' utilizzare.",
                "correction": "SELECT studenti.id FROM studenti, insegnanti;"
            },
            "2": {
                "name": "Colonna ambigua",
                "description": "Quando si usano pi√π tabelle in una query, una colonna presente in pi√π di una tabella viene referenziata senza specificare a quale tabella appartiene.",
                "example": "SELECT id FROM studenti, insegnanti;",
                "explanation": "Entrambe le tabelle contengono una colonna chiamata 'id'. Senza specificare la tabella, il database non pu√≤ determinare quale 'id' utilizzare.",
                "correction": "SELECT studenti.id FROM studenti, insegnanti;"
            },
            "3": {
                "name": "Funzione ambigua",
                "description": "Esistono pi√π funzioni con lo stesso nome e la query non specifica quale utilizzare.",
                "example": "CREATE FUNCTION my_function(interval) RETURNS text AS $$ SELECT 'Interval'; $$ LANGUAGE sql;\nCREATE FUNCTION my_function(time) RETURNS text AS $$ SELECT 'Time'; $$ LANGUAGE sql;\n\nSELECT my_function(NULL);",
                "explanation": "Ci sono due funzioni chiamate 'my_function', una che prende un intervallo e un'altra che prende un orario. La query non specifica quale funzione utilizzare, portando ad ambiguit√†.",
                "correction": "SELECT my_function(NULL::interval);"
            },
            "4": {
                "name": "Colonna non definita",
                "description": "La query referenzia una colonna che non esiste nella tabella o nelle tabelle specificate.",
                "example": "SELECT carta_di_credito FROM studenti;",
                "explanation": "La tabella studenti non contiene una colonna chiamata 'carta_di_credito'.",
                "correction": "SELECT nome FROM studenti;"
            },
            "5": {
                "name": "Funzione non definita",
                "description": "La query fa riferimento a una funzione che non esiste o non √® definita.",
                "example": "SELECT CAPSLOCK(name) FROM studenti;",
                "explanation": "La funzione CAPSLOCK non esiste nel database.",
                "correction": "SELECT UPPER(name) FROM studenti;"
            },
            "6": {
                "name": "Parametro non definito",
                "description": "La query fa riferimento a un parametro che non esiste o non √® definito. Inoltre, i parametri segnaposto sono usati in modo errato.",
                "example": "SELECT ? FROM studenti WHERE id = :param;",
                "explanation": "La query utilizza parametri segnaposto invece di valori effettivi. Questa √® una sintassi valida nelle istruzioni preparate, ma non nelle query regolari.",
                "correction": "SELECT nome FROM studenti WHERE id = 1;"
            },
            "7": {
                "name": "Oggetto non definito",
                "description": "La query fa riferimento a una tabella che non esiste o non √® definita.",
                "example": "SELECT * FROM gatti;",
                "explanation": "La tabella gatti non esiste nel database.",
                "correction": "SELECT * FROM studenti;"
            },
            "8": {
                "name": "Nome schema non valido",
                "description": "La query fa riferimento a uno schema che non esiste o non √® definito.",
                "example": "SELECT * FROM scuola.studenti;",
                "explanation": "Lo schema scuola non esiste nel database. In questo esempio, la tabella studenti risiede nello schema pubblico.",
                "correction": "SELECT * FROM public.studenti;"
            },
            "9": {
                "name": "Errori di ortografia",
                "description": "La query contiene nomi di tabelle, nomi di colonne o altri identificatori scritti in modo errato.",
                "example": "SELECT * FROM studnets;",
                "explanation": "La tabella studnets non esiste nel database. √à un errore di ortografia di 'studenti'.",
                "correction": "SELECT * FROM studenti;"
            },
            "10": {
                "name": "Sinonimi",
                "description": "La query utilizza sinonimi o nomi alternativi per tabelle o colonne che non esistono.",
                "example": "SELECT * FROM alunni;",
                "explanation": "La tabella alunni non esiste nel database. √à un sinonimo di 'studenti', che √® il nome corretto della tabella.",
                "correction": "SELECT * FROM studenti;"
            },
            "11": {
                "name": "Virgolette mancanti attorno ai dati di tipo carattere",
                "description": "I valori di tipo carattere non sono racchiusi tra virgolette, come richiesto per le stringhe.",
                "example": "SELECT * FROM studenti WHERE nome = John;",
                "explanation": "I valori di tipo carattere devono essere racchiusi tra virgolette singole per essere riconosciuti come stringhe.",
                "correction": "SELECT * FROM studenti WHERE nome = 'John';"
            },
            "12": {
                "name": "Mancata specifica del nome della colonna due volte",
                "description": "Quando si utilizzano pi√π condizioni sulla stessa colonna, il nome della colonna non √® specificato per ogni condizione.",
                "example": "SELECT * FROM studenti WHERE et√† > 18 AND < 25;",
                "explanation": "Ogni condizione nella clausola WHERE deve specificare esplicitamente il nome della colonna a cui si applica.",
                "correction": "SELECT * FROM studenti WHERE et√† > 18 AND et√† < 25;"
            },
            "13": {
                "name": "Data type mismatch",
                "description": "The query uses incompatible data types in an operation or comparison.",
                "example": "SELECT * FROM students WHERE name = 7;",
                "explanation": "The condition in the WHERE clause compares a string column (name) with an integer value (7), which is not valid.",
                "correction": "SELECT * FROM students WHERE name = 'John';"
            },
            "14": {
                "name": "Using aggregate function outside SELECT or HAVING",
                "description": "An aggregate function is used in a part of the query where it is not allowed, such as WHERE or GROUP BY.",
                "example": "SELECT * FROM students WHERE AVG(score) > 80;",
                "explanation": "Aggregate functions can only be used in the SELECT clause or the HAVING clause when grouping results. This query is attempting to use AVG in the WHERE clause, which is not allowed.",
                "correction": "SELECT * FROM students GROUP BY class HAVING AVG(score) > 80;"
            },
            "15": {
                "name": "Grouping error: aggregate functions cannot be nested",
                "description": "Aggregate functions cannot be nested within each other in a query.",
                "example": "SELECT SUM(AVG(score)) FROM students GROUP BY class;",
                "explanation": "This query attempts to nest the AVG function inside the SUM function, which is not allowed. Instead, you can use a subquery to first calculate the average scores per group and then sum those averages.",
                "correction": "SELECT SUM(score) FROM (SELECT AVG(score) AS score FROM students GROUP BY class) AS avg_scores;"
            },
            "16": {
                "name": "Grouping error: extraneous or omitted grouping column",
                "description": "When using GROUP BY, all non-aggregated columns in the SELECT clause must be included in the GROUP BY clause. Only aggregated columns or columns included in the GROUP BY clause can be referenced in the HAVING clause.",
                "example": "SELECT name, AVG(score) FROM students GROUP BY class;",
                "explanation": "The query selects the column 'name' which is neither aggregated nor included in the GROUP BY clause. This leads to ambiguity about which 'name' to return for each group. To fix this, either include 'name' in the GROUP BY clause or remove it from the SELECT clause.",
                "correction": "SELECT class, AVG(score) FROM students GROUP BY class;"
            },
            "17": {
                "name": "Strange HAVING: HAVING without GROUP BY",
                "description": "The query uses a HAVING clause without a corresponding GROUP BY clause.",
                "example": "SELECT * FROM students HAVING AVG(score) > 80;",
                "explanation": "The HAVING clause is used to filter grouped results and should always be used in conjunction with a GROUP BY clause.",
                "correction": "SELECT class, AVG(score) FROM students GROUP BY class HAVING AVG(score) > 80;"
            },
            "18": {
                "name": "Confusing function with function parameter",
                "description": "A function is confused with its parameter, leading to incorrect query syntax or logic.",
                "example": "SELECT (COUNT) course FROM students;",
                "explanation": "The query incorrectly uses parentheses around the function name COUNT, which makes it look like a parameter rather than a function call. The correct syntax is to use COUNT without parentheses around it.",
                "correction": "SELECT COUNT(course) FROM students;"
            },
            "19": {
                "name": "Using WHERE twice",
                "description": "The query contains multiple WHERE clauses, which is not allowed.",
                "example": "SELECT * FROM students WHERE age > 18 WHERE grade = 'A';",
                "explanation": "A query can only have one WHERE clause. Combine multiple conditions using logical operators like AND or OR.",
                "correction": "SELECT * FROM students WHERE age > 18 AND grade = 'A';"
            },
            "20": {
                "name": "Omitting the FROM clause",
                "description": "The query is missing the FROM clause and does not select a constant value.",
                "example": "SELECT name WHERE age > 18;",
                "explanation": "The FROM clause is required in a SELECT statement to specify the table from which to retrieve data.",
                "correction": "SELECT name FROM students WHERE age > 18;"
            },
            "21": {
                "name": "Comparison with NULL",
                "description": "The query uses a comparison with NULL using operators like = or != instead of IS NULL or IS NOT NULL.",
                "example": "SELECT * FROM students WHERE name = NULL;",
                "explanation": "When checking for NULL values, use IS NULL or IS NOT NULL instead of standard comparison operators.",
                "correction": "SELECT * FROM students WHERE name IS NULL;"
            },
            "22": {
                "name": "Omitting the semicolon",
                "description": "The query is missing the terminating semicolon at the end of the statement.",
                "example": "SELECT * FROM students",
                "explanation": "SQL standard requires each statement to end with a semicolon (;). Make sure to include it at the end of your queries.",
                "correction": "SELECT * FROM students;"
            },
            "23": {
                "name": "Date time field overflow",
                "description": "An invalid date or time value is used in the query.",
                "example": "SELECT * FROM events WHERE event_date = '2024-02-33';",
                "explanation": "The date '2024-02-33' is invalid because a month cannot have 33 days. Ensure that date and time values are valid according to the calendar.",
                "correction": "SELECT * FROM events WHERE event_date = '2024-02-28';"
            },
            "24": {
                "name": "Duplicate clause",
                "description": "A clause is repeated in the query, such as multiple WHERE or ORDER BY clauses.",
                "example": "SELECT * FROM students ORDER BY age ORDER BY name;",
                "explanation": "This query is invalid because it contains two ORDER BY clauses. Each clause should only appear once in a query.",
                "correction": "SELECT * FROM students ORDER BY age, name;"
            },
            "25": {
                "name": "Using an undefined correlation name",
                "description": "The query references a correlation name (alias) that has not been defined.",
                "example": "SELECT s2.name FROM students AS s;",
                "explanation": "This query renames the students table to 's' but then tries to reference it as 's2', which is not defined.",
                "correction": "SELECT s.name FROM students AS s;"
            },
            "26": {
                "name": "Too many columns in subquery",
                "description": "A subquery returns more columns than expected in the context where it is used.",
                "example": "SELECT * FROM students WHERE id IN (SELECT * FROM teachers);",
                "explanation": "The subquery in the WHERE clause is expected to return a single column of values to compare against the id column in the outer query. However, it returns all columns from the teachers table, leading to a mismatch.",
                "correction": "SELECT * FROM students WHERE id IN (SELECT id FROM teachers);"
            },
            "27": {
                "name": "Confusing table names with column names",
                "description": "A table name is used where a column name is expected, or vice versa.",
                "example": "SELECT name.students FROM students, teachers;",
                "explanation": "This query tries the access a column called 'students' from the 'name' table, which does not exist. The correct syntax is to specify the table name followed by the column name.",
                "correction": "SELECT students.name FROM students, teachers;"
            },
            "28": {
                "name": "Restriction in SELECT clause",
                "description": "",
                "example": "SELECT fee > 10 FROM customers;",
                "explanation": "",
                "correction": ""
            },
            "29": {
                "name": "Projection in WHERE clause",
                "description": "Multiple columns are listed in the WHERE clause instead of a boolean expression.",
                "example": "SELECT * FROM students WHERE firstname, surname;",
                "explanation": "This query incorrectly lists multiple columns in the WHERE clause, instead of a condition that evaluates to true or false. The WHERE clause should contain a boolean expression that filters the rows based on specified criteria.",
                "correction": "SELECT * FROM students WHERE firstname = 'John' AND surname = 'Doe';"
            },
            "30": {
                "name": "Confusing the order of keywords",
                "description": "Keywords in the SQL statement are in the wrong order.",
                "example": "FROM students SELECT name;",
                "explanation": "Ensure that SQL keywords are in the correct order: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET.",
                "correction": "SELECT name FROM students;"
            },
            "31": {
                "name": "Confusing the logic of keywords",
                "description": "The wrong keyword is used for the intended operation, such as using GROUP BY instead of ORDER BY.",
                "example": "ORDER name FROM students;",
                "explanation": "This query mixes up the SELECT and ORDER BY keywords. The correct syntax is to first SELECT the columns and then ORDER the results.",
                "correction": "SELECT name FROM students ORDER BY name;"
            },
            "32": {
                "name": "Confusing the syntax of keywords",
                "description": "Each SQL keyword has a specific syntax that must be followed.",
                "example": "SELECT * FROM students WHERE age BETWEEN 18;",
                "explanation": "The BETWEEN operator requires two values to define the range: a lower bound and an upper bound.",
                "correction": "SELECT * FROM students WHERE age BETWEEN 18 AND 25;"
            },
            "33": {
                "name": "Omitting commas",
                "description": "When listing multiple columns or values, commas are missing between them.",
                "example": "SELECT firstname lastname age FROM students;",
                "explanation": "This query is missing commas between the column names in the SELECT clause. Ensure that each column name is separated by a comma.",
                "correction": "SELECT firstname, lastname, age FROM students;"
            },
            "34": {
                "name": "Curly, square or unmatched brackets",
                "description": "Curly and square brackets are used instead of parentheses, or parentheses are unmatched.",
                "example": "SELECT * FROM students WHERE age > [(15 + 18) * 2] / (7 + 3;",
                "explanation": "Use only parentheses () for grouping expressions in SQL, and ensure that all opening parentheses have a corresponding closing parenthesis.",
                "correction": "SELECT * FROM students WHERE age > ((15 + 18) * 2) / (7 + 3);"
            },
            "35": {
                "name": "IS where not applicable",
                "description": "The IS operator is used for comparisons on values other than NULL or boolean expressions.",
                "example": "SELECT * FROM students WHERE age IS 18;",
                "explanation": "The IS operator should only be used for checking NULL values or boolean expressions (e.g., IS TRUE, IS FALSE). For other comparisons, use standard comparison operators like =, <>, >, <, >=, <=.",
                "correction": "SELECT * FROM students WHERE age = 18;"
            },
            "36": {
                "name": "Nonstandard keywords or standard keywords in wrong context",
                "description": "The query uses invalid keywords or standard keywords in inappropriate contexts.",
                "example": "SELECT * FROM students SORT BY name;",
                "explanation": "The correct keyword for sorting results in SQL is ORDER BY, not SORT BY.",
                "correction": "SELECT * FROM students ORDER BY name;"
            },
            "37": {
                "name": "Nonstandard operators",
                "description": "The query uses operators that are not part of the standard SQL syntax, such as &&, ||, or == instead of AND, OR, or =.",
                "example": "SELECT * FROM students WHERE age == 18 && grade == 'A';",
                "explanation": "Use standard SQL operators for logical and comparison operations: AND, OR, =, <>, >, <, >=, <=. Other operators, although common in programming languages, are not valid in SQL.",
                "correction": "SELECT * FROM students WHERE age = 18 AND grade = 'A';"
            },
            "38": {
                "name": "Additional semicolon",
                "description": "An extra semicolon is present in the query, which can lead to syntax errors.",
                "example": "SELECT * FROM students;;",
                "explanation": "Ensure that there is only one semicolon at the end of the SQL statement.",
                "correction": "SELECT * FROM students;"
            },
            "39": {
                "name": "AND instead of OR (empty result table)",
                "description": "Query uses AND where OR is needed, resulting always in an empty result set.",
                "example": "SELECT * FROM students WHERE age < 18 AND age > 25;",
                "explanation": "The condition age < 18 AND age > 25 is attempting to find students who are both younger than 18 and older than 25 at the same time, which is impossible. Use OR to find students who meet either condition.",
                "correction": "SELECT * FROM students WHERE age < 18 OR age > 25;"
            },
            "40": {
                "name": "Implied, tautological or inconsistent expression",
                "description": "Query contains expressions that are always true, always false, or logically redundant.",
                "example": "SELECT * FROM students WHERE age > 10 AND age > 5 OR name = name;",
                "explanation": "The expression age > 10 AND age > 5 is redundant because if age is greater than 10, it is inherently greater than 5. Additionally, the condition name = name is always true for all rows. Simplifying the query to remove these redundancies will improve clarity and performance.",
                "correction": "SELECT * FROM students WHERE age > 10;"
            },
            "41": {
                "name": "DISTINCT in SUM or AVG",
                "description": "Using DISTINCT within SUM or AVG means that only unique values are summed or averaged, which is almost never the intended behavior.",
                "example": "SELECT AVG(DISTINCT age) FROM students;",
                "explanation": "This query first considers all the unique students ages (each value is counted only once) and then calculates the average of those unique ages. If there are 200 students aged 20 and 1 student aged 30, the average will be (20 + 30) / 2 = 25, which does not accurately reflect the average age of all students.",
                "correction": "SELECT AVG(age) FROM students;"
            },
            "42": {
                "name": "DISTINCT that might remove important duplicates",
                "description": "Using DISTINCT removes duplicate rows from the result set, which may inadvertently exclude important data.",
                "example": "SELECT DISTINCT name from students WHERE grade = 'A';",
                "explanation": "If multiple students share the same name and have received an 'A' grade, using DISTINCT will return only one instance of that name, potentially omitting other students with the same name who also earned an 'A'. This could lead to incomplete or misleading results.",
                "correction": "SELECT name from students WHERE grade = 'A';"
            },
            "43": {
                "name": "Wildcards without LIKE",
                "description": "Wildcards such as % or _ are used with = instead of LIKE, resulting in a literal comparison rather than a pattern match.",
                "example": "SELECT * FROM students WHERE name = 'J%n';",
                "explanation": "This query selects all students whose name is exactly 'J%n', including the percent sign, rather than matching names that start with 'J' and end with 'n' with any characters in between.",
                "correction": "SELECT * FROM students WHERE name LIKE 'J%n';"
            },
            "44": {
                "name": "Incorrect wildcard: using _ instead of % or using, e.g., *",
                "description": "Wildcards are used incorrectly in pattern matching, such as using _ when % is needed, or using non-standard wildcards like *.",
                "example": "SELECT * FROM students WHERE name LIKE 'J*n';",
                "explanation": "The query uses the non-standard wildcard * instead of the SQL standard wildcard %. The * character is not recognized by LIKE for pattern matching in SQL and is instead treated as a literal character.",
                "correction": "SELECT * FROM students WHERE name LIKE 'J%n';"
            },
            "45": {
                "name": "Mixing a > 0 with IS NOT NULL or empty string with NULL",
                "description": "Using > 0 or = '' to check for non-null values instead of IS NOT NULL or IS NULL.",
                "example": "SELECT * FROM students WHERE test_score = '';",
                "explanation": "This query erroneously attempts to find students who haven't taken the test by checking for an empty string in the test_score column. However, this query actually selects students who have taken the test and have been assigned a score of '' (empty string).",
                "correction": "SELECT * FROM students WHERE test_score IS NULL;"
            },
            "46": {
                "name": "NULL in IN/ANY/ALL subquery",
                "description": "Using nullable values in IN, ANY, or ALL subqueries can lead to unexpected results due to the way NULLs are handled in SQL.",
                "example": "SELECT * FROM students WHERE age IN (SELECT age FROM teachers);",
                "explanation": "This query attempts to find students who have the same age as any teacher. However, if the subquery returns any NULL values, the entire IN condition evaluates to UNKNOWN for those rows, which means they will not be included in the result set. This can lead to missing data if there are NULL ages in the teachers table.",
                "correction": "SELECT * FROM students WHERE age IN (SELECT age FROM teachers WHERE age IS NOT NULL);"
            },
            "47": {
                "name": "Join on incorrect column (matches impossible)",
                "description": "A join is performed on columns that cannot logically match, resulting in an empty result set.",
                "example": "SELECT * FROM students JOIN teachers ON students.age = teachers.salary;",
                "explanation": "This query attempts to join the students and teachers tables based on the condition that a student's age equals a teacher's salary. Since age and salary are fundamentally different types of data, this join condition is illogical and will likely result in no matching rows.",
                "correction": "SELECT * FROM students JOIN teachers ON students.class_id = teachers.class_id;"
            },
            "48": {
                "name": "Omitting a join",
                "description": "A join condition is missing or incomplete, leading to a Cartesian product or incorrect results.",
                "example": "SELECT class.name, teacher.name FROM classes, teachers;",
                "explanation": "This query retrieves all combinations of classes and teachers without specifying how they are related. This results in a Cartesian product, where every class is paired with every teacher, which is not the intended outcome.",
                "correction": "SELECT class.name, teacher.name FROM classes, teachers WHERE classes.teacher_id = teachers.id;"
            },
            "49": {
                "name": "Many duplicates",
                "description": "The query returns many times the same values, making the results difficult to interpret.",
                "example": "SELECT city FROM students;",
                "explanation": "This query aims to find all the cities where students live. However, if multiple students live in the same city, that city will appear multiple times in the result set, leading to redundancy and making it harder to analyze the data.",
                "correction": "SELECT DISTINCT city FROM students;"
            },
            "50": {
                "name": "Constant column output",
                "description": "A column in the output has the same constant value for all rows.",
                "example": "SELECT name, country WHERE country = 'IT' FROM students;",
                "explanation": "The country column does not provide any useful information because it has the same value ('IT') for all students in the result set. This redundancy can clutter the output and make it harder to focus on relevant data.",
                "correction": "SELECT name FROM students WHERE country = 'IT';"
            },
            "51": {
                "name": "Duplicate column output",
                "description": "Multiple columns in the output always contain identical values.",
                "example": "SELECT first_name, last_name, first_name FROM students;",
                "explanation": "The query selects the first_name column twice, resulting in duplicate data in the output. This redundancy can confuse users and make it harder to interpret the results.",
                "correction": "SELECT first_name, last_name FROM students;"
            },
            "52": {
                "name": "OR instead of AND",
                "description": "A condition uses OR where AND is needed, leading to broader results than intended.",
                "example": "SELECT * FROM students WHERE age > 18 OR grade = 'A';",
                "explanation": "This query is supposed to find students who are older than 18 and have received an 'A' grade. However, using OR means that it will return all students who are either older than 18 or have an 'A' grade.",
                "correction": "SELECT * FROM students WHERE age > 18 AND grade = 'A';"
            },
            "53": {
                "name": "Extraneous NOT operator",
                "description": "A condition uses NOT where it is not needed, leading to incorrect results.",
                "example": "SELECT * FROM students WHERE age > 18 AND NOT grade = 'A';",
                "explanation": "This query is intended to find students who are older than 18 and have received an 'A' grade. However, the NOT operator negates the grade condition, resulting in students who are older than 18 but have not received an 'A' grade.",
                "correction": "SELECT * FROM students WHERE age > 18 AND grade = 'A';"
            },
            "54": {
                "name": "Missing NOT operator",
                "description": "A condition is missing a NOT operator, leading to incorrect results.",
                "example": "SELECT * FROM students WHERE age > 18 AND grade = 'A';",
                "explanation": "This query is intended to find students who are older than 18 and have not received an 'A' grade. However, without the NOT operator, it returns students who have received an 'A' grade.",
                "correction": "SELECT * FROM students WHERE age > 18 AND NOT grade = 'A';"
            },
            "55": {
                "name": "Substituting existence negation with <>",
                "description": "The query uses <> to check for non-existence instead of NOT IN or NOT EXISTS.",
                "example": "SELECT * FROM students WHERE id <> (SELECT student_id FROM graduates);",
                "explanation": "This query attempts to find students who are not graduates by using the <> operator. However, this query actually returns students whose id is not equal to the single value returned by the subquery, which is not the intended behavior. To correctly find students who are not graduates, use NOT IN or NOT EXISTS.",
                "correction": "SELECT * FROM students WHERE id NOT IN (SELECT student_id FROM graduates);"
            },
            "56": {
                "name": "Putting NOT in front of incorrect IN/EXISTS",
                "description": "When multiple IN/EXISTS subqueries are used, NOT is applied to the wrong one, leading to incorrect results.",
                "example": "SELECT * FROM students WHERE id NOT IN (SELECT student_id FROM graduates) AND id IN (SELECT student_id FROM enrolled);",
                "explanation": "This query is intended to find students who are enrolled but not graduates. However, the NOT operator is applied to the first IN subquery, which checks for graduates, instead of the second IN subquery, which checks for enrolled students. This results in incorrect filtering of the students.",
                "correction": "SELECT * FROM students WHERE id IN (SELECT student_id FROM enrolled) AND id NOT IN (SELECT student_id FROM graduates);"
            },
            "57": {
                "name": "Incorrect comparison operator or incorrect value compared",
                "description": "A condition uses the wrong comparison operator or compares against an incorrect value, leading to unintended results.",
                "example": "SELECT * FROM students WHERE age >= 25;",
                "explanation": "This query is intended to find students who are 18 years old or older. However, the wrong age value is used in the comparison, resulting in only students who are 25 years old or older being returned.",
                "correction": "SELECT * FROM students WHERE age >= 18;"
            },
            "58": {
                "name": "Join on incorrect table",
                "description": "The query refences the wrong table, leading to incorrect or unexpected results.",
                "example": "SELECT name FROM teachers;",
                "explanation": "This query is intended to retrieve the names of students, but it mistakenly references the teachers table instead of the students table.",
                "correction": "SELECT name FROM students;"
            },
            "59": {
                "name": "Join when join needs to be omitted",
                "description": "The query references more tables than necessary, leading to incorrect or unexpected results.",
                "example": "SELECT name FROM students, teachers WHERE ...;",
                "explanation": "This query is intended to retrieve the names of students that meet certain criteria, but it unnecessarily joins the teachers table, which is not needed for this purpose. This can lead to incorrect results if there are multiple teachers associated with a student or if there are no matching teachers.",
                "correction": "SELECT name FROM students WHERE ...;"
            },
            "60": {
                "name": "Join on incorrect column (matches possible)",
                "description": "A join condition uses the wrong column, leading to incorrect or unexpected results.",
                "example": "SELECT students.name FROM students JOIN teachers ON students.class_id = teachers.favourite_number;",
                "explanation": "This query is intended to retrieve the names of students who are associated with specific teachers. However, the join condition uses the favourite_number column from the teachers table, which is not logically related to the class_id column from the students table. This can lead to incorrect or unexpected results, as the join may match students with unrelated teachers based on arbitrary favourite numbers.",
                "correction": "SELECT students.name FROM students JOIN teachers ON students.class_id = teachers.class_id;"
            },
            "61": {
                "name": "Join with incorrect comparison operator",
                "description": "A join condition uses the wrong comparison operator, leading to incorrect or unexpected results.",
                "example": "SELECT students.name FROM students JOIN teachers ON students.class_id > teachers.class_id;",
                "explanation": "This query is intended to retrieve the names of students who are associated with specific teachers. However, the join condition uses the > operator, which checks for a greater-than relationship between students.class_id and teachers.class_id. This is not the intended behavior, as the join should be based on equality to correctly associate students with their teachers.",
                "correction": "SELECT students.name FROM students JOIN teachers ON students.class_id = teachers.class_id;"
            },
            "62": {
                "name": "Missing join",
                "description": "The query refences less tables than necessary, leading to incomplete results.",
                "example": "SELECT students.name FROM students WHERE ...;",
                "explanation": "This query is intended to retrieve the names of students who are associated with specific teachers. However, it does not include a join with the teachers table, which is necessary to filter students based on their associated teachers. As a result, the query may return incomplete results or fail to apply the intended filtering criteria.",
                "correction": "SELECT students.name FROM students, teachers WHERE ...;"
            },
            "63": {
                "name": "Improper nesting of expressions",
                "description": "Expressions are not properly nested with parentheses, leading to incorrect evaluation order.",
                "example": "SELECT * FROM students WHERE age + 5 * 2 > 30;",
                "explanation": "This query is intended to find students whose age plus 5, multiplied by 2, is greater than 30. However, without proper parentheses, the multiplication operator (*) has a higher precedence than addition (+), leading to an incorrect evaluation order.",
                "correction": "SELECT * FROM students WHERE (age + 5) * 2 > 30;"
            },
            "64": {
                "name": "Improper nesting of subqueries",
                "description": "Subqueries are nested improperly, leading to a different evaluation order than intended.",
                "example": "SELECT * FROM students s WHERE id NOT EXISTS (SELECT * FROM graduates g WHERE g.student_id = s.id AND EXISTS (SELECT * FROM tutors t WHERE t.student_id = s.id));",
                "explanation": "This query is intended to find students who are not graduates and have tutors. However, the nesting of the EXISTS subquery within the NOT EXISTS subquery returns students who are not graduates or have tutors, but not both.",
                "correction": "SELECT * FROM students s WHERE NOT EXISTS (SELECT * FROM graduates g WHERE g.student_id = s.id) AND EXISTS (SELECT * FROM tutors t WHERE t.student_id = s.id);"
            },
            "65": {
                "name": "Extraneous quotes",
                "description": "A column name is enclosed in quotes, effectively turning it into a string literal.",
                "example": "SELECT * FROM students WHERE name = 'supervisor_name';",
                "explanation": "This query is intended to find students who have the same name as their supervisor. However, by enclosing supervisor_name in quotes, it returns students whose name is literally 'supervisor_name', rather than comparing it to the value in the supervisor_name column.",
                "correction": "SELECT * FROM students WHERE name = supervisor_name;"
            },
            "66": {
                "name": "Missing expression"
            },
            "67": {
                "name": "Expression on incorrect column"
            },
            "68": {
                "name": "Extraneous expression"
            },
            "69": {
                "name": "Expression in incorrect clause"
            },
            "70": {
                "name": "Extraneous column in SELECT",
                "description": "A column is included in the SELECT clause that is not expected or needed for the intended result.",
                "example": "SELECT name, age, address FROM students;",
                "explanation": "The exercise requires only the names and ages of students, but the query also includes the address column in the SELECT clause. This adds unnecessary data to the result set.",
                "correction": "SELECT name, age FROM students;"
            },
            "71": {
                "name": "Missing column from SELECT",
                "description": "A required column is missing from the SELECT clause.",
                "example": "SELECT name FROM students;",
                "explanation": "The exercise requires both the names and ages of students, but the query only selects the name column, omitting the age column.",
                "correction": "SELECT name, age FROM students;"
            },
            "72": {
                "name": "Missing DISTINCT from SELECT",
                "description": "A DISTINCT keyword is missing from the SELECT clause, leading to duplicate rows in the result set where uniqueness is required by the exercise.",
                "example": "SELECT city FROM students;",
                "explanation": "The exercise requires a list of unique cities where students live. However, the query does not include the DISTINCT keyword, resulting in duplicate city names in the output.",
                "correction": "SELECT DISTINCT city FROM students;"
            },
            "73": {
                "name": "Missing AS from SELECT",
                "description": "A column presents a different name from what is required by the exercise, due to the absence of an AS alias.",
                "example": "SELECT name FROM students;",
                "explanation": "The exercise requires the output column to be labeled as 'student_name', but the query does not use an AS alias to rename the column.",
                "correction": "SELECT name AS student_name FROM students;"
            },
            "74": {
                "name": "Missing column from ORDER BY clause",
                "description": "A required column is missing from the ORDER BY clause.",
                "example": "SELECT name, age FROM students ORDER BY name;",
                "explanation": "The exercise requires the results to be ordered by both name and age. However, the query only orders the results by name, omitting age from the ORDER BY clause.",
                "correction": "SELECT name, age FROM students ORDER BY name, age;"
            },
            "75": {
                "name": "Incorrect column in ORDER BY clause",
                "description": "An incorrect column is used in the ORDER BY clause, leading to results being sorted in an unintended manner.",
                "example": "SELECT name, age FROM students ORDER BY city;",
                "explanation": "The exercise requires the results to be ordered by name, but the query incorrectly orders the results by city instead.",
                "correction": "SELECT name, age FROM students ORDER BY name;"
            },
            "76": {
                "name": "Extraneous ORDER BY clause",
                "description": "An ORDER BY clause is included in the query when the exercise does not require any specific ordering of the results.",
                "example": "SELECT name, age FROM students ORDER BY name;",
                "explanation": "The exercise does not specify any ordering for the results, so including an ORDER BY clause is unnecessary and adds complexity to the query.",
                "correction": "SELECT name, age FROM students;"
            },
            "77": {
                "name": "Incorrect ordering of rows",
                "description": "The ORDER BY clause sorts the results in the wrong order (ascending instead of descending, or vice versa).",
                "example": "SELECT name, age FROM students ORDER BY age ASC;",
                "explanation": "The exercise requires the results to be ordered by age in descending order, but the query sorts the results in ascending order instead.",
                "correction": "SELECT name, age FROM students ORDER BY age DESC;"
            },
            "78": {
                "name": "DISTINCT as function parameter where not applicable",
                "description": "DISTINCT is used within a function where it is not appropriate or necessary.",
                "example": "SELECT COUNT(DISTINCT supervisor) FROM students;",
                "explanation": "The exercise expects the total number of students who have a supervisor assigned, but the DISTICT keyword causes the COUNT function to count only unique supervisors, which is not the intended behavior.",
                "correction": "SELECT COUNT(supervisor) FROM students;"
            },
            "79": {
                "name": "Missing DISTINCT from function parameter",
                "description": "DISTINCT is missing within a function where it is required to ensure unique values are considered.",
                "example": "SELECT COUNT(supervisor) FROM students;",
                "explanation": "The exercise requires counting the number of supervisors assigned to students, counting each supervisor only once, regardless of how many students they supervise. However, the query counts all supervisor entries, including duplicates.",
                "correction": "SELECT COUNT(DISTINCT supervisor) FROM students;"
            },
            "80": {
                "name": "Incorrect function",
                "description": "An incorrect function is used for the intended operation, leading to unexpected results.",
                "example": "SELECT SUM(age) FROM students;",
                "explanation": "The exercise requires calculating the average age of students, but the query uses the SUM function instead of AVG, resulting in the total age rather than the average.",
                "correction": "SELECT AVG(age) FROM students;"
            },
            "81": {
                "name": "Incorrect column as function parameter",
                "description": "An incorrect column is used as a parameter for a function, leading to unintended results.",
                "example": "SELECT EXTRACT(month FROM birthdate) FROM students;",
                "explanation": "The exercise asks for the month the students graduated, but the query extracts the month of their birthdate instead.",
                "correction": "SELECT EXTRACT(month FROM graduation_date) FROM students;"
            },
            "82": {
                "name": "Unnecessary complication",
                "description": "The query is more complex than necessary to achieve the intended result.",
                "example": "SELECT name FROM students WHERE age > 36 / 2 OR age = 9 * (12 - 2);",
                "explanation": "The exercise requires selecting students at least 18 years old. However, the query uses unnecessary arithmetic operations to express the age condition, making it more complicated than needed.",
                "correction": "SELECT name FROM students WHERE age >= 18;"
            },
            "83": {
                "name": "Unnecessary DISTINCT in SELECT clause",
                "description": "DISTINCT is used on a SELECT clause where duplicate values cannot occur, adding unnecessary complexity.",
                "example": "SELECT DISTINCT id, name FROM students;",
                "explanation": "The id column is a primary key, meaning each value is unique. Therefore, using DISTINCT is redundant since there cannot be any duplicate rows in the result set based on the id column.",
                "correction": "SELECT id, name FROM students;"
            },
            "84": {
                "name": "Unnecessary join",
                "description": "A table is joined just to access a value which is already available as a foreign key.",
                "example": "SELECT s.id, t.id FROM students s JOIN teachers t ON s.supervisor_id = t.id;",
                "explanation": "The exercise requires selecting the student IDs along with their supervisor IDs. However, the query unnecessarily joins the teachers table to retrieve the supervisor IDs, which are already available in the students table as foreign keys.",
                "correction": "SELECT id, supervisor_id FROM students;"
            },
            "85": {
                "name": "Unused correlation name",
                "description": "A correlation name (alias) is defined for a table but not used in the query.",
                "example": "SELECT name FROM students s;",
                "explanation": "The query defines a correlation name 's' for the students table but does not use it anywhere in the query. This adds unnecessary complexity without any benefit.",
                "correction": "SELECT name FROM students;"
            },
            "86": {
                "name": "Correlation names are always identical",
                "description": "The query references two tables that always contain the same data.",
                "example": "SELECT a.name, b.name FROM students a JOIN students b ON a.id = b.id;",
                "explanation": "The query joins the students table with itself on the id column, which is a primary key. Since each id is unique, the join will always pair each student with themselves, resulting in identical data from both tables. This redundancy adds unnecessary complexity without any benefit.",
                "correction": "SELECT name FROM students;"
            },
            "86bis": {
                "name": "Redundant correlation name",
                "description": "The query defines a correlation name (alias) for a table that is the same as the original table name, making the alias redundant.",
                "example": "SELECT students.name FROM students AS students students;",
                "explanation": "The query defines a correlation name 'students' for the students table, which is identical to the original table name. This redundancy adds unnecessary complexity without any benefit.",
                "correction": "SELECT students.name FROM students;"
            },
            "87": {
                "name": "Unnecessarily general comparison operator",
                "description": "An operator used for a comparison can be replaced by a more specific one without changing the logic.",
                "example": "SELECT * FROM students WHERE age >= (SELECT MAX(age) FROM students);",
                "explanation": "The query is intended to find the oldest students. However, the \">\" part of the operator is unnecessary because no student can be older than the maximum age. Using the more specific \"=\" operator makes the query clearer and more efficient.",
                "correction": "SELECT * FROM students WHERE age = (SELECT MAX(age) FROM students);"
            },
            "88": {
                "name": "LIKE without wildcards",
                "description": "The LIKE operator is used without any wildcard characters, making it equivalent to a simple equality comparison.",
                "example": "SELECT * FROM students WHERE name LIKE 'John';",
                "explanation": "The query uses the LIKE operator to compare the name column to 'John' without any wildcard characters. This makes the LIKE operator unnecessary, as it behaves the same way as the = operator in this case.",
                "correction": "SELECT * FROM students WHERE name = 'John';"
            },
            "89": {
                "name": "Unnecessarily complicated SELECT in EXISTS subquery",
                "description": "The SELECT clause in an EXISTS subquery returns more than a single column, which is unnecessary since EXISTS only checks for the existence of rows.",
                "example": "SELECT name FROM students s WHERE EXISTS (SELECT id, name FROM teachers t WHERE t.name = s.name);",
                "explanation": "The EXISTS subquery is intended to find students who have the same name as any teacher. However, the SELECT clause in the subquery returns both id and name columns, which is unnecessary because EXISTS only checks for the existence of rows that meet the condition. Returning multiple columns adds unnecessary complexity without any benefit.",
                "correction": "SELECT name FROM students s WHERE EXISTS (SELECT 1 FROM teachers t WHERE t.name = s.name);"
            },
            "90": {
                "name": "IN/EXISTS can be replaced by comparison",
                "description": "A subuery using IN or EXISTS can be simplified to a direct comparison.",
                "example": "SELECT * FROM students WHERE id NOT IN (SELECT id FROM students WHERE age < 18);",
                "explanation": "The query finds students who are 18 years old or older by selecting those whose IDs are not in the set of IDs of students younger than 18. This can be simplified by checking the age directly, which is more straightforward and efficient.", 
                "correction": "SELECT * FROM students WHERE age >= 18;"
            },
            "91": {
                "name": "Unnecessary aggregate function",
                "description": "An aggregate function is used on a single value.",
                "example": "SELECT MAX(age) FROM students WHERE id = 123;",
                "explanation": "The query retrieves the age of a specific student with id 123. Since the WHERE clause filters the results to a single row, using the MAX aggregate function is unnecessary, as there is only one value to return.",
                "correction": "SELECT age FROM students WHERE id = 123;"
            },
            "92": {
                "name": "Unnecessary DISTINCT in aggregate function",
                "description": "DISTINCT is used within an aggregate function where all values are already unique, making it redundant.",
                "example": "SELECT COUNT(DISTINCT id) FROM students;",
                "explanation": "The id column is a primary key, meaning each value is unique. Therefore, using DISTINCT within the COUNT function doesn't change the result, as there cannot be any duplicate ids to count.",
                "correction": "SELECT COUNT(id) FROM students;"
            },
            "93": {
                "name": "Unnecessary argument of COUNT",
                "description": "COUNT is used with a specific column name instead of using COUNT(*) or COUNT(1) when counting non-nullable columns.",
                "example": "SELECT COUNT(name) FROM students;",
                "explanation": "The name column is defined as NOT NULL, meaning it cannot contain any NULL values. Therefore, using COUNT(name) is equivalent to COUNT(*), as all rows will be counted. Using COUNT(*) is more straightforward and efficient in this case.",
                "correction": "SELECT COUNT(*) FROM students;"
            },
            "94": {
                "name": "Unnecessary GROUP BY in EXISTS subquery",
                "description": "A GROUP BY clause is used in an EXISTS subquery where it is not needed, as EXISTS only checks for the existence of rows.",
                "example": "SELECT name FROM students s WHERE EXISTS (SELECT 1 FROM teachers t GROUP BY t.name HAVING t.name = s.name);",
                "explanation": "The EXISTS subquery is intended to find students who have the same name as any teacher. However, the GROUP BY clause is unnecessary because EXISTS only checks for the existence of rows that meet the condition. Using GROUP BY adds unnecessary complexity without any benefit.",
                "correction": "SELECT name FROM students s WHERE EXISTS (SELECT 1 FROM teachers t WHERE t.name = s.name);"
            },
            "95": {
                "name": "GROUP BY with singleton groups",
                "description": "GROUP BY is used on groups that each contain only a single row, making the grouping unnecessary.",
                "example": "SELECT id, AVG(age) FROM students GROUP BY id;",
                "explanation": "The query groups the students by their id, which is a primary key. Since each id is unique, each group will contain only a single row. Therefore, using GROUP BY is unnecessary, as it does not change the result set.",
                "correction": "SELECT id, age FROM students;"
            },
            "96": {
                "name": "GROUP BY with only a single group",
                "description": "GROUP BY is used in a way that results in only a single group, making the grouping unnecessary.",
                "example": "SELECT AVG(age) FROM students WHERE country = 'IT' GROUP BY country;",
                "explanation": "The query groups the students by country after filtering for those in 'IT'. Since all remaining rows belong to the same country, there is only a single group. Therefore, using GROUP BY is unnecessary, as it does not change the result set.",
                "correction": "SELECT AVG(age) FROM students WHERE country = 'IT';"
            },
            "97": {
                "name": "GROUP BY can be replaced with DISTINCT",
                "description": "All GROUP BY columns are also in the SELECT clause without any aggregate functions, making DISTINCT a simpler alternative.",
                "example": "SELECT name, age FROM students GROUP BY name, age;",
                "explanation": "The query groups the students by their name and age, but does not use any aggregate functions. Since the SELECT clause only includes the grouped columns, using DISTINCT is a simpler and more efficient way to achieve the same result.",
                "correction": "SELECT DISTINCT name, age FROM students;"
            },
            "98": {
                "name": "UNION can be replaced by OR",
                "description": "Two SELECT statements combined with UNION can be simplified to a single SELECT with an OR condition.",
                "example": "SELECT name FROM students WHERE age < 18 UNION SELECT name FROM students WHERE grade = 'A';",
                "explanation": "The query retrieves the names of students who are either younger than 18 or have received an 'A' grade. This can be simplified by using a single SELECT statement with an OR condition in the WHERE clause, which is more straightforward and efficient.",
                "correction": "SELECT name FROM students WHERE age < 18 OR grade = 'A';"
            },
            "99": {
                "name": "Unnecessary column in ORDER BY clause",
                "description": "A column is included in the ORDER BY clause that does not affect the ordering of the results due to functional dependencies.",
                "example": "SELECT id, name FROM students ORDER BY id, name;",
                "explanation": "The query orders the results by both id and name. However, since id is a primary key, it uniquely identifies each row. Therefore, ordering by name after id does not change the order of the results, making it unnecessary.",
                "correction": "SELECT id, name FROM students ORDER BY id;"
            },
            "100": {
                "name": "ORDER BY in subquery",
                "description": "An ORDER BY clause is used in a subquery where it does not affect the final result set.",
                "example": "SELECT name FROM students WHERE name IN (SELECT name FROM teachers ORDER BY name);",
                "explanation": "The query retrieves the names of students who have the same name as any teacher. However, the ORDER BY clause in the subquery is unnecessary, as the order of rows in a subquery does not impact the final result set of the outer query.",
                "correction": "SELECT name FROM students WHERE name IN (SELECT name FROM teachers);"
            },
            "101": {
                "name": "Inefficient HAVING",
                "description": "A condition in the HAVING clause does not depend on aggregate functions and can be moved to the WHERE clause.",
                "example": "SELECT supervisor, COUNT(*) FROM students GROUP BY supervisor HAVING supervisor IS NOT NULL;",
                "explanation": "The HAVING clause is used to filter groups based on aggregate conditions. However, the condition 'supervisor IS NOT NULL' does not depend on any aggregate functions and can be applied before grouping. Moving this condition to the WHERE clause improves query efficiency by reducing the number of rows that need to be grouped.",
                "correction": "SELECT supervisor, COUNT(*) FROM students WHERE supervisor IS NOT NULL GROUP BY supervisor;"
            },
            "102": {
                "name": "Inefficient UNION",
                "description": "A UNION operation can be replaced by UNION ALL without changing the result set, improving performance.",
                "example": "SELECT name FROM students WHERE age < 18 UNION SELECT name FROM students WHERE age > 30;",
                "explanation": "The two queries retrieve names of students from disjoint age groups (younger than 18 and older than 30). Since there is no overlap between these two groups, using UNION ALL is more efficient as it does not perform the additional step of removing duplicates, which is unnecessary in this case.",
                "correction": "SELECT name FROM students WHERE age < 18 UNION ALL SELECT name FROM students WHERE age > 30;"
            },
            "103": {
                "name": "Condition in the subquery can be moved up",
                "description": "A condition in the subquery refences only values from the outer query and can be moved to the outer WHERE clause.",
                "example": "SELECT name FROM students s WHERE EXISTS (SELECT 1 FROM teachers t WHERE t.name = s.name AND s.age > 18);",
                "explanation": "The condition 's.age > 18' in the subquery only references the outer query's table 'students'. Therefore, it can be moved to the outer WHERE clause, which can improve query readability and potentially performance.",
                "correction": "SELECT name FROM students s WHERE s.age > 18 AND EXISTS (SELECT 1 FROM teachers t WHERE t.name = s.name);"
            },
            "104": {
                "name": "Condition on left table in LEFT OUTER JOIN",
                "description": "Using a JOIN ON condition on the left table of a LEFT OUTER JOIN affects only the right table, which can lead to unexpected results.",
                "example": "SELECT s.name, t.name FROM students s LEFT OUTER JOIN teachers t ON s.supervisor_id = t.id AND s.age > 18;",
                "explanation": "The condition 's.age > 18' is applied only on the right table. If a student is younger than 18, the join will still include that student with NULL values for the teacher columns, which is not the internted behavior. To filter students based on age, the condition should be placed in the WHERE clause instead.",
                "correction": "SELECT s.name, t.name FROM students s LEFT OUTER JOIN teachers t ON s.supervisor_id = t.id WHERE s.age > 18;"
            },
            "105": {
                "name": "OUTER JOIN can be replaced by INNER JOIN",
                "description": "Using a WHERE condition on the right table of a LEFT OUTER JOIN effectively turns it into an INNER JOIN.",
                "example": "SELECT s.name, t.name FROM students s LEFT OUTER JOIN teachers t ON s.supervisor_id = t.id WHERE t.department = 'Math';",
                "explanation": "The WHERE condition 't.department = 'Math'' filters out any rows where there is no matching teacher, which negates the purpose of the LEFT OUTER JOIN. In this case, an INNER JOIN is more appropriate and efficient.",
                "correction": "SELECT s.name, t.name FROM students s INNER JOIN teachers t ON s.supervisor_id = t.id WHERE t.department = 'Math';"
            }
        }
    }
}