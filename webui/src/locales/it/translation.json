{
    "components": {
        "navbar": {
            "nav": {
                "home": "Home",
                "profile": "Profilo",
                "view_profile": "Visualizza Profilo",
                "learning": "Statistiche di Apprendimento",
                "datasets": "Dataset",
                "explore_sql": "Esplora SQL",
                "admin": "Admin",
                "login": "Accedi",
                "register": "Registrati",
                "logout": "Disconnetti",
                "loading": "Caricamento...",
                "unknown": "Sconosciuto",
                "username_tooltip": "Il tuo nome utente",
                "admin_tooltip": "Amministratore",
                "teacher_tooltip": "Docente"
            },
            "language": {
                "label": "Lingua",
                "en": "EN",
                "it": "IT"
            },
            "gamification_stats": {
                "level": "Livello",
                "xp": "Punti esperienza",
                "coins": "LensCoins"
            }
        },
        "alert": {
            "under_development": "üöß Questa sezione √® in fase di sviluppo."
        },
        "notifications": {
            "badge": {
                "title": "üèÜ Obiettivo Raggiunto!",
                "exp": "{{count}} EXP",
                "coins": "{{count}} LensCoins"
            },
            "reward": {
                "coin_singular": "LensCoin",
                "coin_plural": "LensCoins",
                "exp": "{{count}} EXP"
            }
        },
        "buttons": {
            "button": {
                "locked_tooltip": "Questa azione √® bloccata",
                "free": "Gratis"
            },
            "modal": {
                "close": "Chiudi"
            },
            "dataset": {
                "title": "Dataset",
                "loading": "Caricamento..."
            }
        },
        "footer": {
            "developed_by": "Sviluppato da Davide Ponzini.",
            "license": "Licenza Pubblica Generale GNU",
            "contact": "Contatta",
            "social": {
                "website": "Sito Web",
                "github": "GitHub",
                "email": "Email"
            }
        },
        "assignmentList": {
            "title": "Assegna a",
            "select_all": "Seleziona tutti"
        },
        "learningStats": {
            "learning": {
                "queries_teacher": "Esploriamo le query dei tuoi studenti",
                "queries_student": "Esploriamo le tue query",
                "messages": "Trasformare le domande in progresso",
                "errors": "Dove le cose si sono complicate"
            },
            "errors": {
                "empty": {
                    "student": "Non hai ancora commesso errori. Quando lo farai, ti mostreremo i tipi di errori e come sono cambiati nel tempo.",
                    "teacher": "I tuoi studenti non hanno ancora commesso errori. Quando lo faranno, ti mostreremo i tipi di errori e come sono cambiati nel tempo."
                },
                "kind_title": "Che tipo di problemi sono emersi?",
                "kind_subtitle": {
                    "student": "I tuoi errori rientrano in alcune categorie principali ‚Äî ecco una panoramica.",
                    "teacher": "Gli errori dei tuoi studenti rientrano in alcune categorie principali ‚Äî ecco una panoramica."
                },
                "kind_body": {
                    "student": "In fase di sviluppo! Questa sezione classificher√† i tuoi errori in sintattici, semantici, logici e complicazioni.",
                    "teacher": "In fase di sviluppo! Questa sezione classificher√† gli errori dei tuoi studenti in sintattici, semantici, logici e complicazioni."
                },
                "common_title": "Errori pi√π comuni",
                "common_subtitle": {
                    "student": "Ecco i pattern di errore pi√π frequenti rilevati nelle tue query.",
                    "teacher": "Ecco i pattern di errore pi√π frequenti rilevati nelle query dei tuoi studenti."
                },
                "common_body": {
                    "student": "In fase di sviluppo! Questa sezione mostrer√† i pattern di errore pi√π frequenti nelle tue query.",
                    "teacher": "In fase di sviluppo! Questa sezione mostrer√† i pattern di errore pi√π frequenti nelle query dei tuoi studenti."
                },
                "timeline_title": {
                    "student": "Come sono cambiati i tuoi errori nel tempo",
                    "teacher": "Come sono cambiati gli errori dei tuoi studenti nel tempo"
                },
                "timeline_subtitle": {
                    "student": "Guarda se stai commettendo meno errori man mano che progredisci.",
                    "teacher": "Guarda se i tuoi studenti stanno commettendo meno errori man mano che progrediscono."
                },
                "count_label": "{{count}} errori",
                "example_label": "Esempio",
                "correction_label": "Correzione",
                "explanation_label": "Spiegazione"
            },
            "messages": {
                "empty": {
                    "student": "Non hai ancora chiesto aiuto. Quando lo farai, ti mostreremo quante volte hai chiesto spiegazioni e quanto hai compreso le risposte.",
                    "teacher": "I tuoi studenti non hanno ancora chiesto aiuto. Quando lo faranno, ti mostreremo quante volte hanno chiesto spiegazioni e quanto hanno compreso le risposte."
                },
                "title_help": {
                    "student": "Tu hai chiesto, Lens ha spiegato",
                    "teacher": "I tuoi studenti hanno chiesto, Lens ha spiegato"
                },
                "subtitle_help": {
                    "student": "Bloccato o curioso? Ecco quando hai chiesto spiegazioni o chiarimenti sulle query.",
                    "teacher": "Bloccati o curiosi? Ecco quando i tuoi studenti hanno chiesto spiegazioni o chiarimenti sulle loro query."
                },
                "list_title": {
                    "student": "Quando hai chiesto aiuto:",
                    "teacher": "Quando i tuoi studenti hanno chiesto aiuto:"
                },
                "list_labels": {
                    "total": "Richieste totali",
                    "select": "Sulle query SELECT"
                },
                "chart_title": {
                    "student": "Cosa stavi cercando:",
                    "teacher": "Cosa stavano cercando i tuoi studenti:"
                },
                "understanding_results": "Comprendere risultati",
                "understanding_errors": "Comprendere errori",
                "title_feedback": {
                    "student": "Hai valutato le risposte",
                    "teacher": "I tuoi studenti hanno valutato le risposte"
                },
                "subtitle_feedback": {
                    "student": "Hai dato un voto positivo o negativo alle spiegazioni ‚Äî questo ci aiuta a migliorare.",
                    "teacher": "I tuoi studenti hanno dato un voto positivo o negativo alle spiegazioni ‚Äî questo ci aiuta a migliorare."
                },
                "feedback_given": "Feedback fornito",
                "feedback_not_given": "Nessun feedback"
            },
            "queries": {
                "empty": {
                    "student": "Non hai ancora eseguito query. Quando lo farai, ti mostreremo quante query hai provato, quante hanno funzionato e quali tipi hai usato.",
                    "teacher": "I tuoi studenti non hanno ancora eseguito query. Quando lo faranno, ti mostreremo quante ne hanno provate, quante hanno funzionato e quali tipi hanno usato."
                },
                "title": {
                    "student": "Il tuo percorso SQL",
                    "teacher": "Il percorso SQL dei tuoi studenti"
                },
                "stats": {
                    "distinct": "Query distinte provate",
                    "total": "Query totali eseguite",
                    "note": "Ogni tentativo conta ‚Äî anche i ripetuti fanno parte dell‚Äôapprendimento."
                },
                "success_title": "Quanto spesso ha funzionato",
                "select_label": "Query SELECT",
                "all_label": "Tutte le query",
                "chart_title": {
                    "student": "Che tipo di query stai eseguendo?",
                    "teacher": "Che tipo di query stanno eseguendo i tuoi studenti?"
                },
                "chart_subtitle": {
                    "student": "Ecco i vari comandi SQL che hai usato e come sono andati.",
                    "teacher": "Ecco i vari comandi SQL che i tuoi studenti hanno usato e come sono andati."
                },
                "chart_empty": {
                    "student": "Nessuna query eseguita. Inizia a esplorare SQL!",
                    "teacher": "Nessuna query eseguita. Aspetta che i tuoi studenti inizino a esplorare SQL!"
                },
                "success": "Corrette",
                "fail": "Errate"
            }
        }
    },
    "pages": {
        "admin": {
            "title": "Pagina di amministrazione",
            "empty": "Nessun contenuto disponibile"
        },
        "datasetes": {
            "dataset": {
                "new": "Nuovo Dataset",
                "save": "Salva"
            },
            "dataset_card": {
                "exercises": "Esercizi",
                "queries": "Query eseguite",
                "badge_teacher": "Docente",
                "join_code": "Codice di iscrizione",
                "students": "Studenti",
                "open": "Apri",
                "leave": "Lascia",
                "confirm_leave": "Sei sicuro di voler abbandonare questo dataset?",
                "my_learning_analytics": "Le mie statistiche di apprendimento",
                "student_learning_analytics": "Statistiche di apprendimento degli studenti",
                "set_teachers": "Imposta Docenti",
                "participants": "Partecipanti"
            },
            "dataset_list": {
                "title": "I miei dataset",
                "empty": "Nessun dataset trovato. Unisciti a un dataset o creane uno nuovo.",
                "new_dataset_suggestion": "Se vuoi eseguire una query non assegnata da un docente, crea un nuovo dataset.",
                "join": "Unisciti a un dataset",
                "join_prompt": "Inserisci il codice del dataset:"
            },
            "dataset_mask": {
                "title_label": "Titolo",
                "dataset_label": "Dataset (Opzionale)",
                "tips_title": "Suggerimenti",
                "tips": [
                    "Includi l'intero script in un blocco <code>BEGIN; ... COMMIT;</code>",
                    "Inizia lo script con <code>DROP SCHEMA IF EXISTS schema_name CASCADE;</code>",
                    "Usa un <code>search_path</code> unico per ogni dataset",
                    "Raggruppa le inserzioni in un unico comando <code>INSERT INTO</code> per ogni tabella per migliorare le prestazioni"
                ],
                "title_placeholder": "Titolo descrittivo del dataset",
                "dataset_str_placeholder": "BEGIN;\n\nDROP SCHEMA IF EXISTS <schema_name> CASCADE;\nCREATE SCHEMA <schema_name>;\nSET search_path TO <schema_name>;\n\nCREATE TABLE ...;\n\nINSERT INTO ...;\n\nCOMMIT;"
            },
            "dataset_update": {
                "modal_title": "Modifica Dataset",
                "button_text": "Modifica",
                "save": "Salva"
            },
            "exercise_add": {
                "title": "Aggiungi Esercizio",
                "button_text": "Nuovo Esercizio",
                "save": "Salva"
            },
            "exercise": {
                "hidden": "Nascosto",
                "solved": "Risolto",
                "generated": "Generato dall'IA",
                "objectives": "Obiettivi di Apprendimento",
                "archive": "Archivia",
                "unarchive": "Annulla Archiviazione",
                "open": "Apri",
                "analytics": "Statistiche di Apprendimento",
                "edit": "Modifica",
                "objectives_set": "Imposta Obiettivi",
                "hide": "Nascondi",
                "show": "Rendi Visibile",
                "delete": "Elimina",
                "delete_confirm": "Sei sicuro di voler eliminare questo esercizio? Questa azione non pu√≤ essere annullata."
            },
            "exercise_list": {
                "title": "Esercizi",
                "none": "Nessun esercizio",
                "archived": "Archiviati",
                "archived_none": "Nessun esercizio archiviato"
            },
            "exercise_mask": {
                "title": "Titolo",
                "request": "Richiesta",
                "answer_optional": "Risposta (facoltativa)",
                "add_answer": "Aggiungi risposta",
                "remove_answer": "Rimuovi risposta",
                "title_placeholder": "Titolo breve e descrittivo per l'esercizio",
                "request_placeholder": "Cosa dovrebbe fare la query?",
                "search_path_label": "Percorso di ricerca della soluzione"
            },
            "exercise_update": {
                "title": "Modifica esercizio",
                "button": "Modifica",
                "save": "Salva"
            },
            "learning_objectives": {
                "title": "Imposta obiettivi",
                "button": "Imposta obiettivi",
                "list_title": "Imposta obiettivi di apprendimento"
            }
        },
        "profile": {
            "learning": {
                "title": "Bentornato, {{username}}!",
                "subtitle": "Ecco una panoramica dei tuoi progressi in SQL"
            },
            "profile": {
                "welcome": "Bentornato, {{username}}!",
                "progress": "Ecco una panoramica dei tuoi progressi",
                "contact_support": "Contatta il supporto",
                "level": {
                    "title": "Livello Attuale",
                    "exp": "EXP: {{xp}} / {{xpToNext}}",
                    "tip": "Ottieni pi√π EXP studiando SQL:",
                    "earn_exp": "Come guadagnare EXP"
                },
                "coins": {
                    "title": "LensCoins",
                    "available": "{{coins}} monete disponibili",
                    "tip": "Usa i LensCoins per interagire con Lens:",
                    "earn_coins": "Come guadagnare LensCoins"
                },
                "achievements": {
                    "title": "Obiettivi",
                    "text": "Hai ottenuto i seguenti obiettivi:"
                },
                "settings": "Impostazioni",
                "change_password": {
                    "title": "Cambia Password",
                    "current_password_label": "Password Attuale",
                    "new_password_label": "Nuova Password",
                    "confirm_new_password_label": "Conferma Nuova Password",
                    "submit_button": "Aggiorna Password",
                    "current_required": "Inserisci la tua password attuale.",
                    "confirm_required": "Conferma la tua nuova password.",
                    "password_mismatch_alert": "Le password non corrispondono.",
                    "success_alert": "La tua password √® stata aggiornata con successo!",
                    "error_generic": "Si √® verificato un errore imprevisto durante l'aggiornamento della password."
                }
            }
        },
        "about": {
            "title": "Informazioni su LensQL",
            "p1": "LensQL √® una piattaforma interattiva che aiuta gli studenti a imparare SQL attraverso esercitazioni guidate, feedback personalizzati e un percorso di apprendimento gamificato. Progettata per studenti e insegnanti, favorisce una comprensione pi√π profonda dei database relazionali, concentrandosi sul ragionamento dietro le query, non solo sulla loro correttezza.",
            "p2": "Anzich√© fornire soluzioni immediate, LensQL incoraggia l‚Äôesplorazione attiva. L‚Äôassistente AI, Lens, aiuta gli studenti a riflettere sugli errori, affinare la logica e migliorare le competenze con ogni tentativo. Gli insegnanti, nel frattempo, ottengono una panoramica su come apprendono gli studenti, dove incontrano difficolt√† e come supportarli al meglio.",
            "p3": "Che tu stia eseguendo la tua prima query o perfezionando join complessi, LensQL trasforma ogni errore in un‚Äôopportunit√† di apprendimento.",
            "moreTitle": "üîç Vuoi saperne di pi√π?",
            "moreIntro": "LensQL √® sviluppato come parte di una ricerca in corso presso l‚ÄôUniversit√† di Genova. Se sei curioso di approfondire gli aspetti accademici o tecnici, ecco alcune pubblicazioni che ne esplorano i fondamenti:",
            "paper1": "Analyzing Common Student Errors in SQL Query Formulation to Enhance Learning Support",
            "paper1Desc": "Uno studio su larga scala sugli errori SQL degli studenti e le differenze nei diversi contesti educativi.",
            "paper2": "Enhancing SQL Learning through Generative AI and Student Error Analysis",
            "paper2Desc": "Un framework per feedback AI-driven, tracciamento degli errori e generazione personalizzata di esercizi nell'insegnamento di SQL.",
            "cta": "Prova LensQL"
        },
        "login": {
            "title": "Accedi al tuo account",
            "subtitle": "Non hai un account? Registrati qui",
            "username": "Nome utente",
            "usernamePlaceholder": "Nome utente",
            "usernameRequired": "Inserisci un nome utente.",
            "password": "Password",
            "passwordPlaceholder": "Password",
            "passwordRequired": "Inserisci una password.",
            "show": "Mostra password",
            "hide": "Nascondi password",
            "submit": "Accedi",
            "errorEmptyFields": "Compila entrambi i campi.",
            "errorServer": "Impossibile connettersi al server.",
            "errorLoginFailed": "Accesso non riuscito"
        },
        "register": {
            "title": "Registrati con un nuovo account",
            "subtitle": "Hai gi√† un account? Accedi qui",
            "success": "Registrazione completata! Ora puoi accedere con il tuo nuovo account.",
            "gotoLogin": "Vai al Login",
            "submit": "Registrati",
            "username": "Nome utente",
            "usernamePlaceholder": "Nome utente",
            "usernameRequired": "Inserisci un nome utente.",
            "password": "Password",
            "passwordPlaceholder": "Password",
            "passwordRequired": "Inserisci una password.",
            "passwordLength": "La password deve contenere almeno 8 caratteri.",
            "passwordUpper": "La password deve contenere almeno una lettera maiuscola.",
            "passwordLower": "La password deve contenere almeno una lettera minuscola.",
            "passwordDigit": "La password deve contenere almeno un numero.",
            "passwordSpecial": "La password deve contenere almeno un carattere speciale.",
            "show": "Mostra password",
            "hide": "Nascondi password",
            "email": "Email (opzionale)",
            "emailPlaceholder": "Email",
            "emailRequired": "Inserisci un indirizzo email.",
            "emailInvalid": "Inserisci un indirizzo email valido.",
            "school": "Scuola",
            "schoolPlaceholder": "Scuola",
            "schoolRequired": "Inserisci la tua scuola.",
            "errorServer": "Impossibile connettersi al server.",
            "errorGeneric": "Registrazione fallita"
        },
        "exercises": {
            "buttons": {
                "category": {
                    "database": "Database",
                    "exercise": "Esercizio",
                    "query": "Query"
                },
                "database": {
                    "show_search_path": "Mostra Search Path",
                    "list_tables": "Elenca Tabelle",
                    "list_tables_current": "Schema Corrente",
                    "list_tables_all": "Tutti gli Schemi",
                    "list_schemas": "Elenca Schemi",
                    "list_constraints": "Elenca Vincoli"
                },
                "exercise": {
                    "dataset": "Dataset",
                    "create": "Crea",
                    "check_result": "Verifica Risultato",
                    "no_solution": "Soluzione non disponibile",
                    "attempt_singular": "{{count}} tentativo",
                    "attempt_plural": "{{count}} tentativi",
                    "dataset_error": "Errore durante la creazione del dataset. Controlla la console per i dettagli.\nSe il dataset √® molto grande, prova a eseguire i comandi manualmente in piccoli blocchi."
                },
                "query": {
                    "execute": "Esegui",
                    "clear_output": "Pulisci output",
                    "query_too_large": "Query troppo lunga. Prova a dividerla in parti pi√π piccole. Devi rimuovere almeno {{excess}} caratteri."
                }
            },
            "exercises": {
                "loading": "Caricamento..."
            },
            "message": {
                "feedback_invite": "Puoi guadagnare LensCoins fornendo feedback su questo messaggio"
            },
            "messageBox": {
                "assistant_name": "Lens",
                "user_name": "Tu"
            },
            "query": {
                "back_to_top": "Torna in cima"
            },
            "query_result": {
                "builtin": "Funzione incorporata di LensQL",
                "user": "Query utente"
            },
            "chat": {
                "initial_prompt": "Vuoi chiedermi qualcosa su questo risultato?",
                "followup_prompt": "Vuoi chiedere qualcos'altro?",
                "thinking": "Lens sta pensando...",
                "buttons": {
                    "describe": "Cosa fa la mia query?",
                    "explain": "Cosa fa la mia query in dettaglio?",
                    "explain_error": "Cosa significa questo errore?",
                    "example": "Cosa pu√≤ causare questo errore?",
                    "locate": "Dove si trova il problema nella mia query?",
                    "fix": "Come posso correggere questo errore?",
                    "detect_errors": "La mia query ha degli errori?"
                },
                "prompts": {
                    "describe": "Cosa fa la mia query? Fornisci un riassunto conciso del suo comportamento.",
                    "explain": "Cosa fa la mia query in dettaglio? Spiega cosa fa ogni clausola della mia query.",
                    "explain_error": "Cosa significa questo errore? Spiega il messaggio di errore in termini semplici.",
                    "example": "Cosa pu√≤ causare questo errore? Fornisci una query di esempio semplificata che potrebbe portare a questo errore.",
                    "locate": "Dove si trova il problema nella mia query? Mostrami quale parte della query sta causando questo errore.",
                    "fix": "Come posso correggere questo errore? Suggerisci una possibile correzione per questo errore.",
                    "detect_errors": "La mia query ha degli errori? Analizza la mia query e identifica eventuali problemi."
                }
            }
        },
        "home": {
            "hero": {
                "title": "Impara SQL Sbagliando ‚Äì Con LensQL",
                "subtitle": "Scopri SQL. Impara dagli errori. Cresci con Lens.",
                "description": "LensQL √® una piattaforma di apprendimento SQL potenziata dall'IA che trasforma gli errori degli studenti in momenti di apprendimento personalizzati e interattivi.",
                "cta_register": "Crea o Unisciti a un Dataset",
                "cta_about": "Come Funziona LensQL"
            },
            "what_is": {
                "title": "Cos'√® LensQL?",
                "subtitle": "Un modo pi√π intelligente per imparare SQL ‚Äî basato sui tuoi errori, potenziato dall'IA.",
                "features": {
                    "ai_tutor": "ü§ñ <strong>Tutor basato su IA</strong> che aiuta gli studenti a fare debug delle query e a pensare criticamente",
                    "error_pedagogy": "üß† <strong>Pedagogia basata sugli errori</strong>: impara da errori di sintassi, logica e semantica",
                    "personalization": "üéØ <strong>Compiti e dashboard personalizzati</strong> basati sui progressi reali"
                },
                "quote": "‚ÄúOltre il 95% delle query vengono eseguite fuori dall‚Äôorario di lezione. LensQL supporta l‚Äôapprendimento riflessivo e autonomo.‚Äù"
            },
            "how_it_works": {
                "title": "Come Funziona LensQL",
                "steps": [
                    "üßë‚Äçüè´ Gli insegnanti creano esercizi, se vogliono, mirati a errori comuni",
                    "üéì Gli studenti risolvono query con l‚Äôaiuto di Lens ‚Äî niente risposte dirette, solo guida interattiva",
                    "üìä Il sistema analizza ogni query per rilevare errori e tracciare i progressi",
                    "üõ†Ô∏è Esercizi personalizzati vengono generati automaticamente per colmare lacune specifiche",
                    "üìà Dashboard interattive mostrano come evolve la comprensione nel tempo"
                ],
                "cta_research": "Guarda la ricerca alla base"
            },
            "meet_lens": {
                "title": "Conosci Lens: il tuo compagno SQL",
                "description": "Lens era un esploratore di antichi dati ‚Äî finch√© una misteriosa query SQL non l'ha trasformato in un'IA. Ora guida gli studenti attraverso i JOIN e i WHERE con curiosit√†, chiarezza e gentilezza.",
                "features": {
                    "explain_errors": "‚ùì <strong>Spiega gli errori</strong> in modo semplice",
                    "locate_mistakes": "üìå <strong>Aiuta a localizzare gli errori</strong> nella tua query",
                    "show_examples": "üß™ <strong>Mostra esempi</strong> di query simili",
                    "describe_query": "üß≠ <strong>Descrive il comportamento della query</strong> per riflettere su intento e risultato",
                    "suggest_after_reflection": "‚ö†Ô∏è <strong>Offre suggerimenti solo dopo la riflessione</strong> ‚Äî per favorire un apprendimento autentico"
                }
            },
            "why_errors": {
                "title": "Perch√© Imparare dagli Errori?",
                "students": {
                    "title": "Per gli Studenti",
                    "items": [
                        "üß† <strong>Capire il perch√©</strong>, non solo il come",
                        "üîÅ <strong>Migliorare con prove e tentativi</strong>",
                        "üöÄ <strong>Sviluppare abilit√† di debugging e metacognitive</strong>"
                    ]
                },
                "teachers": {
                    "title": "Per i Docenti",
                    "items": [
                        "üìä <strong>Individuare incomprensioni in anticipo</strong>",
                        "üß© <strong>Osservare percorsi di apprendimento</strong>, non solo risposte corrette",
                        "üõ†Ô∏è <strong>Adattare il supporto</strong> con dati concreti"
                    ]
                }
            },
            "gamification": {
                "title": "üéÆ Apprendimento Gamificato che Premia Sforzo e Intuizione",
                "description": "Imparare SQL dovrebbe essere gratificante ‚Äî e anche un po‚Äô divertente. LensQL usa due sistemi di progressione per motivare gli studenti a esercitarsi, riflettere e crescere.",
                "xp": {
                    "title": "üîπ XP e Livelli ‚Äî Progredisci con la Pratica",
                    "description": "Guadagna esperienza scrivendo ed eseguendo query. Salire di livello mostra i tuoi progressi e premia la costanza ‚Äî non solo le risposte giuste.",
                    "quote": "‚ÄúNon devi essere perfetto ‚Äî solo costante. Pi√π sperimenti, pi√π impari.‚Äù"
                },
                "coins": {
                    "title": "ü™ô LensCoins ‚Äî Usali con Cura, Rifletti a Fondo",
                    "description": "I LensCoins si guadagnano con l‚Äôimpegno e si spendono quando chiedi aiuto a Lens. Ti incoraggiano a provare prima ‚Äî e a riflettere dopo.",
                    "quote": "‚ÄúI LensCoins incentivano la riflessione. Spendili quando sei davvero bloccato ‚Äî e riguadagnali risolvendo e aiutando Lens a migliorare.‚Äù"
                },
                "why": {
                    "title": "üí° Perch√© Funziona",
                    "items": [
                        "üéØ Incentiva <strong>sperimentazione</strong>, non perfezione",
                        "üìà Premia <strong>impegno costante</strong> e apprendimento attivo",
                        "ü§ù Crea un <strong>dialogo</strong> tra studente e assistente IA",
                        "üîÑ Aiuta i docenti a vedere <strong>chi si impegna, non solo chi riesce</strong>"
                    ]
                }
            },
            "dashboard": {
                "title": "üìä Il Tuo Cruscotto di Apprendimento",
                "students": {
                    "title": "Per gli Studenti",
                    "items": [
                        "üìå Tieni traccia di quante query esegui e con quale successo",
                        "üìä Comprendi che tipo di query scrivi e come cambiano nel tempo",
                        "ü§ñ Osserva quando e perch√© interagisci con Lens e come reagisci ai suoi suggerimenti",
                        "üïí Segui i tuoi progressi nel tempo attraverso le query e gli errori"
                    ]
                },
                "teachers": {
                    "title": "Per i Docenti",
                    "items": [
                        "üìä Visualizza metriche aggregate per ogni classe: attivit√†, successo e uso dell‚Äôassistente",
                        "üìÇ Analizza gli errori per categoria: sintattici, semantici, logici o complicazioni",
                        "üïí Tieni traccia dell‚Äôevoluzione nel tempo delle query e degli errori",
                        "üß≠ Adatta la didattica in base a ci√≤ che gli studenti provano, non solo a ci√≤ che riescono"
                    ]
                }
            },
            "demo": {
                "title": "üöÄ Prova LensQL Ora",
                "description": "LensQL richiede registrazione, ma ecco un‚Äôanteprima di come ti aiuta a ragionare sugli errori passo dopo passo.",
                "example_caption": "Esempio: <code>SELECT name FROM students WHERE grade &gt; AVG(grade)</code>",
                "example_note": "Lens identifica un errore di sintassi e lo spiega in modo semplice, senza fornire la risposta."
            },
            "community": {
                "title": "ü§ù Entra nella Community di LensQL",
                "description": "Gi√† utilizzato da <strong>oltre 100 studenti</strong> al di fuori della classe.",
                "teachers": {
                    "title": "‚úÖ Per i Docenti",
                    "items": [
                        "üìö Crea corsi",
                        "üìù Assegna esercizi",
                        "üìä Monitora l'apprendimento della classe"
                    ]
                },
                "students": {
                    "title": "‚úÖ Per gli Studenti",
                    "items": [
                        "üí¨ Ottieni feedback immediato",
                        "üí° Allena il tuo SQL con uno scopo",
                        "üõ†Ô∏è Supera le tue difficolt√†"
                    ]
                }
            },
            "cta": {
                "title": "üí° Imparare SQL non inizia dalle risposte. Inizia dagli errori.",
                "register": "Crea il Tuo Account",
                "about": "Scopri di pi√π"
            }
        }
    },
    "gamification": {
        "actions": {
            "solve_exercises": {
                "label": "Risolvi esercizi",
                "xp": "+1000 XP",
                "coins": "+100 monete"
            },
            "run_queries": {
                "label": "Esegui query",
                "xp": "+5 XP",
                "coins": ""
            },
            "try_unique_queries": {
                "label": "Prova nuove query uniche",
                "xp": "+25 XP per nuova query",
                "coins": ""
            },
            "interact_with_lens": {
                "label": "Interagisci con Lens",
                "xp": "+5 XP",
                "coins": ""
            },
            "feedback_on_lens": {
                "label": "Dai un feedback sull‚Äôaiuto di Lens",
                "xp": "+5 XP",
                "coins": "+10 monete"
            },
            "achievements": {
                "label": "Sblocca obiettivi",
                "xp": "quantit√† variabili",
                "coins": "quantit√† variabili"
            },
            "check_solution": {
                "label": "Controlla se la soluzione √® corretta",
                "xp": "",
                "coins": "da 0 a -5 monete"
            },
            "ask_lens": {
                "label": "Chiedi aiuto a Lens",
                "xp": "",
                "coins": "da -1 a -10 monete"
            },
            "_variable_amounts": "Quantit√† variabili"
        },
        "badges": {
            "locked": "Bloccato",
            "rank": "Grado {{rank}}",
            "create_exercises": {
                "name": "Creatore di Esercizi",
                "description": "Crea esercizi ed esegui query in essi",
                "next": "Esercizi per il prossimo grado",
                "next_locked": "Esercizi per sbloccare",
                "levels": {
                    "1": "Creato il tuo primo esercizio ed eseguito una query in esso",
                    "5": "Creato 5 esercizi ed eseguito una query in ciascuno di essi",
                    "10": "Creato 10 esercizi ed eseguito una query in ciascuno di essi"
                }
            },
            "feedback": {
                "name": "Fornitore di Feedback",
                "description": "Fornisci feedback sull'aiuto di Lens",
                "next": "Feedback per il prossimo grado",
                "next_locked": "Feedback per sbloccare",
                "levels": {
                    "1": "Fornito il tuo primo feedback",
                    "10": "Fornito feedback 10 volte",
                    "50": "Fornito feedback 50 volte"
                }
            },
            "queries_unique": {
                "name": "Interrogatore Curioso",
                "description": "Prova query diverse",
                "next": "Query uniche per il prossimo grado",
                "next_locked": "Query uniche per sbloccare",
                "levels": {
                    "1": "Eseguita la tua prima query",
                    "10": "Eseguite 10 query diverse",
                    "50": "Eseguite 50 query diverse",
                    "100": "Eseguite 100 query diverse",
                    "500": "Eseguite 500 query diverse",
                    "1000": "Eseguite 1000 query diverse",
                    "2500": "Eseguite 2500 query diverse",
                    "5000": "Eseguite 5000 query diverse",
                    "10000": "Eseguite 10000 query diverse"
                }
            },
            "exercise_solutions": {
                "name": "Risolutore di Esercizi",
                "description": "Risolvi esercizi",
                "next": "Esercizi risolti per il prossimo grado",
                "next_locked": "Esercizi risolti per sbloccare",
                "levels": {
                    "1": "Risolto il tuo primo esercizio",
                    "5": "Risolti 5 esercizi",
                    "10": "Risolti 10 esercizi"
                }
            },
            "help_usage": {
                "name": "Conversatore con Lens",
                "description": "Interagisci con Lens",
                "next": "Interazioni per il prossimo grado",
                "next_locked": "Interazioni per sbloccare",
                "levels": {
                    "1": "Interagito con Lens per la prima volta",
                    "10": "Interagito con Lens 10 volte",
                    "50": "Interagito con Lens 50 volte",
                    "100": "Interagito con Lens 100 volte",
                    "500": "Interagito con Lens 500 volte",
                    "1000": "Interagito con Lens 1000 volte"
                }
            },
            "daily_usage": {
                "name": "Apprendista Quotidiano",
                "description": "Esegui una query in giorni diversi",
                "next": "Giorni di attivit√† per il prossimo grado",
                "next_locked": "Giorni di attivit√† per sbloccare",
                "levels": {
                    "5": "Esegui una query in 5 giorni diversi",
                    "14": "Esegui una query in 14 giorni diversi",
                    "30": "Esegui una query in 30 giorni diversi"
                }
            },
            "level_up": {
                "name": "Salitore di Livelli",
                "description": "Salita di livello",
                "next": "Livelli per il prossimo grado",
                "next_locked": "Livelli per sbloccare",
                "levels": {
                    "3": "Raggiunto il livello 3",
                    "5": "Raggiunto il livello 5",
                    "10": "Raggiunto il livello 10"
                }
            },
            "join_dataset": {
                "name": "Esploratore di Dataset",
                "description": "Unisciti ai dataset",
                "next": "Dataset uniti per il prossimo grado",
                "next_locked": "Dataset uniti per sbloccare",
                "levels": {
                    "1": "Unito al tuo primo dataset"
                }
            }
        },
        "levels": {
            "0": "Principiante curioso",
            "1": "Pensatore logico",
            "2": "Apprendista delle query",
            "3": "Cercatore di pattern",
            "4": "Esploratore relazionale",
            "5": "Analista intenzionale",
            "6": "Interprete dei dati",
            "7": "Costruttore di intuizioni",
            "8": "Pensatore strutturato",
            "9": "Architetto delle query"
        }
    },
    "learning_objectives": {
        "Simple Select": {
            "label": "SELECT semplice",
            "description": "Scrivi un'istruzione SELECT semplice per recuperare dati da una sola tabella."
        },
        "Single condition": {
            "label": "Condizione singola",
            "description": "Scrivi query che filtrano i risultati in base a una sola condizione."
        },
        "Distinct": {
            "label": "DISTINCT",
            "description": "Usa la parola chiave DISTINCT per eliminare righe duplicate dai risultati."
        },
        "Aggregate functions": {
            "label": "Funzioni di aggregazione",
            "description": "Usa funzioni come COUNT, SUM, AVG, MIN e MAX per riassumere i dati."
        },
        "Subquery in SELECT": {
            "label": "Subquery in SELECT",
            "description": "Scrivi query che includono sottoquery nella clausola SELECT."
        },
        "Case statements": {
            "label": "Istruzioni CASE",
            "description": "Usa le istruzioni CASE per creare logica condizionale nelle query."
        },
        "String functions": {
            "label": "Funzioni stringa",
            "description": "Applica funzioni stringa per manipolare i dati testuali nelle query."
        },
        "Date functions": {
            "label": "Funzioni di data",
            "description": "Usa funzioni di data per manipolare e formattare dati temporali."
        },
        "Numeric functions": {
            "label": "Funzioni numeriche",
            "description": "Applica funzioni numeriche per effettuare calcoli su dati numerici."
        },
        "Window functions": {
            "label": "Funzioni finestra",
            "description": "Usa le funzioni finestra per calcolare risultati su insiemi di righe correlate."
        },
        "Simple join": {
            "label": "JOIN semplice",
            "description": "Scrivi query che utilizzano un join tra due tabelle per ottenere dati correlati."
        },
        "Self join": {
            "label": "SELF JOIN",
            "description": "Scrivi query che utilizzano un self-join per confrontare righe nella stessa tabella."
        },
        "Left join": {
            "label": "LEFT JOIN",
            "description": "Scrivi query che usano LEFT JOIN per ottenere tutte le righe da una tabella e quelle corrispondenti da un'altra."
        },
        "Right join": {
            "label": "RIGHT JOIN",
            "description": "Scrivi query che usano RIGHT JOIN per ottenere tutte le righe da una tabella e quelle corrispondenti da un'altra."
        },
        "Full outer join": {
            "label": "FULL OUTER JOIN",
            "description": "Usa FULL OUTER JOIN per ottenere tutte le righe dove c'√® una corrispondenza in almeno una tabella."
        },
        "Subquery in FROM": {
            "label": "Subquery in FROM",
            "description": "Usa sottoquery nella clausola FROM per creare tabelle derivate."
        },
        "Multiple conditions": {
            "label": "Condizioni multiple",
            "description": "Usa operatori logici per filtrare i risultati in base a pi√π condizioni."
        },
        "Subquery in WHERE": {
            "label": "Subquery in WHERE",
            "description": "Usa sottoquery nella clausola WHERE per filtrare i risultati in base a dati correlati."
        },
        "Correlated subqueries": {
            "label": "Sottoquery correlate",
            "description": "Scrivi sottoquery che fanno riferimento a colonne della query esterna."
        },
        "Group by": {
            "label": "GROUP BY",
            "description": "Raggruppa i risultati usando GROUP BY per aggregare i dati."
        },
        "Group by with conditions": {
            "label": "Clausola HAVING",
            "description": "Usa la clausola HAVING per filtrare i risultati aggregati."
        },
        "Order by": {
            "label": "ORDER BY",
            "description": "Ordina i risultati delle query usando ORDER BY."
        },
        "Limit and offset": {
            "label": "LIMIT e OFFSET",
            "description": "Usa LIMIT e OFFSET per controllare il numero di righe restituite da una query."
        },
        "Union": {
            "label": "UNION",
            "description": "Combina i risultati di pi√π query usando l'operatore UNION."
        },
        "Intersect": {
            "label": "INTERSECT",
            "description": "Recupera risultati comuni a pi√π query usando INTERSECT."
        },
        "Except": {
            "label": "EXCEPT",
            "description": "Usa EXCEPT per trovare righe in una query che non sono presenti in un'altra."
        }
    },
    "errors": {
        "categories": {
            "syn": {
                "name": "Errori sintattici",
                "description": "Sintassi SQL errata, come parole chiave mancanti, punteggiatura errata o istruzioni malformate."
            },
            "sem": {
                "name": "Errori semantici",
                "description": "Sintassi corretta ma query priva di significato, come restituire sempre un insieme di risultati vuoto."
            },
            "log": {
                "name": "Errori logici",
                "description": "La query viene eseguita senza errori ma produce risultati errati a causa di una logica difettosa o di una comprensione errata dei requisiti."
            },
            "com": {
                "name": "Complicazioni",
                "description": "La query restituisce il risultato corretto ma utilizza metodi inefficienti o costrutti complessi che potrebbero essere semplificati."
            }
        },
        "errors": {
            "1": {
                "name": "Omissione dei nomi di correlazione",
                "description": "Quando si usano pi√π tabelle in una query, una colonna presente in pi√π di una tabella viene referenziata senza specificare a quale tabella appartiene.",
                "example": "SELECT id FROM studenti, insegnanti;",
                "explanation": "Entrambe le tabelle contengono una colonna chiamata 'id'. Senza specificare la tabella, il database non pu√≤ determinare quale 'id' utilizzare.",
                "correction": "SELECT studenti.id FROM studenti, insegnanti;"
            },
            "2": {
                "name": "Colonna ambigua",
                "description": "Quando si usano pi√π tabelle in una query, una colonna presente in pi√π di una tabella viene referenziata senza specificare a quale tabella appartiene.",
                "example": "SELECT id FROM studenti, insegnanti;",
                "explanation": "Entrambe le tabelle contengono una colonna chiamata 'id'. Senza specificare la tabella, il database non pu√≤ determinare quale 'id' utilizzare.",
                "correction": "SELECT studenti.id FROM studenti, insegnanti;"
            },
            "3": {
                "name": "Funzione ambigua",
                "description": "Esistono pi√π funzioni con lo stesso nome e la query non specifica quale utilizzare.",
                "example": "CREATE FUNCTION my_function(interval) RETURNS text AS $$ SELECT 'Interval'; $$ LANGUAGE sql;\nCREATE FUNCTION my_function(time) RETURNS text AS $$ SELECT 'Time'; $$ LANGUAGE sql;\n\nSELECT my_function(NULL);",
                "explanation": "Ci sono due funzioni chiamate 'my_function', una che prende un intervallo e un'altra che prende un orario. La query non specifica quale funzione utilizzare, portando ad ambiguit√†.",
                "correction": "SELECT my_function(NULL::interval);"
            },
            "4": {
                "name": "Colonna non definita",
                "description": "La query referenzia una colonna che non esiste nella tabella o nelle tabelle specificate.",
                "example": "SELECT carta_di_credito FROM studenti;",
                "explanation": "La tabella studenti non contiene una colonna chiamata 'carta_di_credito'.",
                "correction": "SELECT nome FROM studenti;"
            },
            "5": {
                "name": "Funzione non definita",
                "description": "La query fa riferimento a una funzione che non esiste o non √® definita.",
                "example": "SELECT CAPSLOCK(name) FROM studenti;",
                "explanation": "La funzione CAPSLOCK non esiste nel database.",
                "correction": "SELECT UPPER(name) FROM studenti;"
            },
            "6": {
                "name": "Parametro non definito",
                "description": "La query fa riferimento a un parametro che non esiste o non √® definito. Inoltre, i parametri segnaposto sono usati in modo errato.",
                "example": "SELECT ? FROM studenti WHERE id = :param;",
                "explanation": "La query utilizza parametri segnaposto invece di valori effettivi. Questa √® una sintassi valida nelle istruzioni preparate, ma non nelle query regolari.",
                "correction": "SELECT nome FROM studenti WHERE id = 1;"
            },
            "7": {
                "name": "Oggetto non definito",
                "description": "La query fa riferimento a una tabella che non esiste o non √® definita.",
                "example": "SELECT * FROM gatti;",
                "explanation": "La tabella gatti non esiste nel database.",
                "correction": "SELECT * FROM studenti;"
            },
            "8": {
                "name": "Nome schema non valido",
                "description": "La query fa riferimento a uno schema che non esiste o non √® definito.",
                "example": "SELECT * FROM scuola.studenti;",
                "explanation": "Lo schema scuola non esiste nel database. In questo esempio, la tabella studenti risiede nello schema pubblico.",
                "correction": "SELECT * FROM public.studenti;"
            },
            "9": {
                "name": "Errori di ortografia",
                "description": "La query contiene nomi di tabelle, nomi di colonne o altri identificatori scritti in modo errato.",
                "example": "SELECT * FROM studnets;",
                "explanation": "La tabella studnets non esiste nel database. √à un errore di ortografia di 'studenti'.",
                "correction": "SELECT * FROM studenti;"
            },
            "10": {
                "name": "Sinonimi",
                "description": "La query utilizza sinonimi o nomi alternativi per tabelle o colonne che non esistono.",
                "example": "SELECT * FROM alunni;",
                "explanation": "La tabella alunni non esiste nel database. √à un sinonimo di 'studenti', che √® il nome corretto della tabella.",
                "correction": "SELECT * FROM studenti;"
            },
            "11": {
                "name": "Virgolette mancanti attorno ai dati di tipo carattere",
                "description": "I valori di tipo carattere non sono racchiusi tra virgolette, come richiesto per le stringhe.",
                "example": "SELECT * FROM studenti WHERE nome = John;",
                "explanation": "I valori di tipo carattere devono essere racchiusi tra virgolette singole per essere riconosciuti come stringhe.",
                "correction": "SELECT * FROM studenti WHERE nome = 'John';"
            },
            "12": {
                "name": "Mancata specifica del nome della colonna due volte",
                "description": "Quando si utilizzano pi√π condizioni sulla stessa colonna, il nome della colonna non √® specificato per ogni condizione.",
                "example": "SELECT * FROM studenti WHERE et√† > 18 AND < 25;",
                "explanation": "Ogni condizione nella clausola WHERE deve specificare esplicitamente il nome della colonna a cui si applica.",
                "correction": "SELECT * FROM studenti WHERE et√† > 18 AND et√† < 25;"
            },
            "13": {
                "name": "Incompatibilit√† di tipi di dati",
                "description": "La query usa tipi di dati incompatibili in un'operazione o in un confronto.",
                "example": "SELECT * FROM studenti WHERE nome = 7;",
                "explanation": "La condizione nella clausola WHERE confronta una colonna di tipo stringa (nome) con un valore intero (7), che non √® valido.",
                "correction": "SELECT * FROM studenti WHERE nome = 'John';"
            },
            "14": {
                "name": "Uso di funzione di aggregazione fuori da SELECT o HAVING",
                "description": "Una funzione di aggregazione √® usata in una parte della query in cui non √® permessa, come WHERE o GROUP BY.",
                "example": "SELECT * FROM studenti WHERE AVG(punteggio) > 80;",
                "explanation": "Le funzioni di aggregazione possono essere usate solo nella clausola SELECT o nella clausola HAVING quando si raggruppano i risultati. Questa query prova a usare AVG nella clausola WHERE, cosa non consentita.",
                "correction": "SELECT * FROM studenti GROUP BY classe HAVING AVG(punteggio) > 80;"
            },
            "15": {
                "name": "Errore di raggruppamento: le funzioni di aggregazione non possono essere annidate",
                "description": "Le funzioni di aggregazione non possono essere annidate l'una dentro l'altra in una query.",
                "example": "SELECT SUM(AVG(punteggio)) FROM studenti GROUP BY classe;",
                "explanation": "Questa query prova ad annidare la funzione AVG dentro la funzione SUM, cosa non consentita. Invece, puoi usare una sottoquery per calcolare prima la media per gruppo e poi sommare quelle medie.",
                "correction": "SELECT SUM(punteggio) FROM (SELECT AVG(punteggio) AS punteggio FROM studenti GROUP BY classe) AS punteggi_medi;"
            },
            "16": {
                "name": "Errore di raggruppamento: colonna di raggruppamento superflua o omessa",
                "description": "Quando si usa GROUP BY, tutte le colonne non aggregate nella clausola SELECT devono essere incluse nella clausola GROUP BY. Solo colonne aggregate o presenti nel GROUP BY possono essere referenziate nella clausola HAVING.",
                "example": "SELECT nome, AVG(punteggio) FROM studenti GROUP BY classe;",
                "explanation": "La query seleziona la colonna 'nome' che non √® n√© aggregata n√© inclusa nella clausola GROUP BY. Questo porta ad ambiguit√† su quale 'nome' restituire per ogni gruppo. Per risolvere, includi 'nome' nel GROUP BY o rimuovilo dalla SELECT.",
                "correction": "SELECT classe, AVG(punteggio) FROM studenti GROUP BY classe;"
            },
            "17": {
                "name": "HAVING senza GROUP BY",
                "description": "La query usa una clausola HAVING senza una corrispondente clausola GROUP BY.",
                "example": "SELECT * FROM studenti HAVING AVG(punteggio) > 80;",
                "explanation": "La clausola HAVING serve a filtrare i risultati raggruppati e dovrebbe essere usata sempre insieme a una clausola GROUP BY.",
                "correction": "SELECT classe, AVG(punteggio) FROM studenti GROUP BY classe HAVING AVG(punteggio) > 80;"
            },
            "18": {
                "name": "Confusione tra funzione e parametro della funzione",
                "description": "Una funzione viene confusa con il suo parametro, portando a sintassi o logica errata.",
                "example": "SELECT (COUNT) corso FROM studenti;",
                "explanation": "La query usa erroneamente le parentesi attorno al nome della funzione COUNT, facendolo sembrare un parametro invece di una chiamata di funzione. La sintassi corretta √® usare COUNT senza parentesi attorno al nome.",
                "correction": "SELECT COUNT(corso) FROM studenti;"
            },
            "19": {
                "name": "Utilizzo di WHERE due volte",
                "description": "La query contiene pi√π clausole WHERE, cosa non consentita.",
                "example": "SELECT * FROM studenti WHERE et√† > 18 WHERE grado = 'A';",
                "explanation": "Una query pu√≤ avere solo una clausola WHERE. Combina pi√π condizioni usando operatori logici come AND o OR.",
                "correction": "SELECT * FROM studenti WHERE et√† > 18 AND grado = 'A';"
            },
            "20": {
                "name": "Omissione della clausola FROM",
                "description": "Alla query manca la clausola FROM e non seleziona un valore costante.",
                "example": "SELECT nome WHERE et√† > 18;",
                "explanation": "La clausola FROM √® obbligatoria in una istruzione SELECT per specificare la tabella da cui recuperare i dati.",
                "correction": "SELECT nome FROM studenti WHERE et√† > 18;"
            },
            "21": {
                "name": "Confronto con NULL",
                "description": "La query usa un confronto con NULL usando operatori come = o != invece di IS NULL o IS NOT NULL.",
                "example": "SELECT * FROM studenti WHERE nome = NULL;",
                "explanation": "Quando si verificano valori NULL, usa IS NULL o IS NOT NULL invece degli operatori di confronto standard.",
                "correction": "SELECT * FROM studenti WHERE nome IS NULL;"
            },
            "22": {
                "name": "Omissione del punto e virgola",
                "description": "Alla query manca il punto e virgola finale alla fine dell'istruzione.",
                "example": "SELECT * FROM studenti",
                "explanation": "Lo standard SQL richiede che ogni istruzione termini con un punto e virgola (;). Assicurati di includerlo alla fine delle query.",
                "correction": "SELECT * FROM studenti;"
            },
            "23": {
                "name": "Overflow del campo data/ora",
                "description": "Nella query viene usato un valore di data o ora non valido.",
                "example": "SELECT * FROM eventi WHERE data_evento = '2024-02-33';",
                "explanation": "La data '2024-02-33' √® non valida perch√© un mese non pu√≤ avere 33 giorni. Assicurati che i valori di data e ora siano validi secondo il calendario.",
                "correction": "SELECT * FROM eventi WHERE data_evento = '2024-02-28';"
            },
            "24": {
                "name": "Clausola duplicata",
                "description": "Una clausola √® ripetuta nella query, come WHERE o ORDER BY multipli.",
                "example": "SELECT * FROM studenti ORDER BY et√† ORDER BY nome;",
                "explanation": "Questa query non √® valida perch√© contiene due clausole ORDER BY. Ogni clausola dovrebbe comparire solo una volta in una query.",
                "correction": "SELECT * FROM studenti ORDER BY et√†, nome;"
            },
            "25": {
                "name": "Uso di un nome di correlazione non definito",
                "description": "La query fa riferimento a un nome di correlazione (alias) che non √® stato definito.",
                "example": "SELECT s2.nome FROM studenti AS s;",
                "explanation": "Questa query rinomina la tabella studenti in 's' ma poi prova a referenziarla come 's2', che non √® definito.",
                "correction": "SELECT s.nome FROM studenti AS s;"
            },
            "26": {
                "name": "Troppe colonne in sottoquery",
                "description": "Una sottoquery restituisce pi√π colonne del previsto nel contesto in cui viene usata.",
                "example": "SELECT * FROM studenti WHERE id IN (SELECT * FROM insegnanti);",
                "explanation": "La sottoquery nella clausola WHERE dovrebbe restituire una singola colonna di valori da confrontare con la colonna id della query esterna. Tuttavia restituisce tutte le colonne dalla tabella insegnanti, causando un disallineamento.",
                "correction": "SELECT * FROM studenti WHERE id IN (SELECT id FROM insegnanti);"
            },
            "27": {
                "name": "Confondere nomi di tabelle e nomi di colonne",
                "description": "Un nome di tabella viene usato dove √® atteso un nome di colonna, o viceversa.",
                "example": "SELECT nome.studenti FROM studenti, insegnanti;",
                "explanation": "Questa query prova ad accedere a una colonna chiamata 'studenti' dalla tabella 'nome', che non esiste. La sintassi corretta √® specificare il nome della tabella seguito dal nome della colonna.",
                "correction": "SELECT studenti.nome FROM studenti, insegnanti;"
            },
            "28": {
                "name": "Restrizione nella clausola SELECT",
                "description": "Nella clausola SELECT viene usata un'espressione booleana invece di selezionare colonne o valori.",
                "example": "SELECT tariffa > 10 FROM clienti;",
                "explanation": "La clausola SELECT restituisce il risultato della condizione booleana 'tariffa > 10' invece di colonne della tabella. Andrebbe spostata nella clausola WHERE o sostituita con le colonne richieste.",
                "correction": "SELECT nome FROM clienti WHERE tariffa > 10;"
            },
            "29": {
                "name": "Proiezione nella clausola WHERE",
                "description": "Nella clausola WHERE vengono elencate pi√π colonne invece di un'espressione booleana.",
                "example": "SELECT * FROM studenti WHERE firstname, surname;",
                "explanation": "Questa query elenca in modo errato pi√π colonne nella clausola WHERE invece di una condizione che restituisca vero o falso. La clausola WHERE deve contenere un'espressione booleana che filtra le righe in base a criteri specificati.",
                "correction": "SELECT * FROM studenti WHERE firstname = 'John' AND surname = 'Doe';"
            },
            "30": {
                "name": "Confondere l'ordine delle parole chiave",
                "description": "Le parole chiave nell'istruzione SQL sono nell'ordine sbagliato.",
                "example": "FROM studenti SELECT nome;",
                "explanation": "Assicurati che le parole chiave SQL siano nell'ordine corretto: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET.",
                "correction": "SELECT nome FROM studenti;"
            },
            "31": {
                "name": "Confondere la logica delle parole chiave",
                "description": "Viene usata la parola chiave sbagliata per l'operazione desiderata, come usare GROUP BY invece di ORDER BY.",
                "example": "ORDER nome FROM studenti;",
                "explanation": "Questa query mescola le parole chiave SELECT e ORDER BY. La sintassi corretta √® selezionare le colonne e poi ordinarne i risultati.",
                "correction": "SELECT nome FROM studenti ORDER BY nome;"
            },
            "32": {
                "name": "Confondere la sintassi delle parole chiave",
                "description": "Ogni parola chiave SQL ha una sintassi specifica che va rispettata.",
                "example": "SELECT * FROM studenti WHERE et√† BETWEEN 18;",
                "explanation": "L'operatore BETWEEN richiede due valori per definire l'intervallo: un limite inferiore e uno superiore.",
                "correction": "SELECT * FROM studenti WHERE et√† BETWEEN 18 AND 25;"
            },
            "33": {
                "name": "Omissione di virgole",
                "description": "Quando si elencano pi√π colonne o valori, mancano le virgole tra di essi.",
                "example": "SELECT nome cognome et√† FROM studenti;",
                "explanation": "Questa query non ha virgole tra i nomi delle colonne nella clausola SELECT. Assicurati che ogni nome di colonna sia separato da una virgola.",
                "correction": "SELECT nome, cognome, et√† FROM studenti;"
            },
            "34": {
                "name": "Parentesi graffe, quadre o non corrispondenti",
                "description": "Vengono usate parentesi graffe o quadre invece delle parentesi tonde, oppure le parentesi non sono bilanciate.",
                "example": "SELECT * FROM studenti WHERE et√† > [(15 + 18) * 2] / (7 + 3;",
                "explanation": "In SQL usa solo le parentesi tonde () per raggruppare le espressioni e assicurati che tutte le parentesi aperte abbiano una corrispondente chiusura.",
                "correction": "SELECT * FROM studenti WHERE et√† > ((15 + 18) * 2) / (7 + 3);"
            },
            "35": {
                "name": "IS dove non applicabile",
                "description": "L'operatore IS √® usato per confronti su valori diversi da NULL o espressioni booleane.",
                "example": "SELECT * FROM studenti WHERE et√† IS 18;",
                "explanation": "L'operatore IS deve essere usato solo per verificare valori NULL o espressioni booleane (es. IS TRUE, IS FALSE). Per altri confronti, usa gli operatori standard come =, <>, >, <, >=, <=.",
                "correction": "SELECT * FROM studenti WHERE et√† = 18;"
            },
            "36": {
                "name": "Parole chiave non standard o parole chiave standard nel contesto sbagliato",
                "description": "La query usa parole chiave non valide o parole chiave standard in contesti inappropriati.",
                "example": "SELECT * FROM studenti SORT BY nome;",
                "explanation": "La parola chiave corretta per ordinare i risultati in SQL √® ORDER BY, non SORT BY.",
                "correction": "SELECT * FROM studenti ORDER BY nome;"
            },
            "37": {
                "name": "Operatori non standard",
                "description": "La query usa operatori che non fanno parte della sintassi SQL standard, come &&, || o == invece di AND, OR o =.",
                "example": "SELECT * FROM studenti WHERE et√† == 18 && grado == 'A';",
                "explanation": "Usa operatori SQL standard per le operazioni logiche e di confronto: AND, OR, =, <>, >, <, >=, <=. Altri operatori, sebbene comuni nei linguaggi di programmazione, non sono validi in SQL.",
                "correction": "SELECT * FROM studenti WHERE et√† = 18 AND grado = 'A';"
            },
            "38": {
                "name": "Punto e virgola aggiuntivo",
                "description": "√à presente un punto e virgola extra nella query, che pu√≤ generare errori di sintassi.",
                "example": "SELECT * FROM studenti;;",
                "explanation": "Assicurati che ci sia un solo punto e virgola alla fine dell'istruzione SQL.",
                "correction": "SELECT * FROM studenti;"
            },
            "39": {
                "name": "AND invece di OR (tabella dei risultati vuota)",
                "description": "La query usa AND dove √® necessario OR, producendo sempre un risultato vuoto.",
                "example": "SELECT * FROM studenti WHERE et√† < 18 AND et√† > 25;",
                "explanation": "La condizione et√† < 18 AND et√† > 25 cerca studenti contemporaneamente pi√π giovani di 18 e pi√π vecchi di 25, cosa impossibile. Usa OR per trovare studenti che soddisfano almeno una delle condizioni.",
                "correction": "SELECT * FROM studenti WHERE et√† < 18 OR et√† > 25;"
            },
            "40": {
                "name": "Espressione implicita, tautologica o incoerente",
                "description": "La query contiene espressioni sempre vere, sempre false o logicamente ridondanti.",
                "example": "SELECT * FROM studenti WHERE et√† > 10 AND et√† > 5 OR nome = nome;",
                "explanation": "L'espressione et√† > 10 AND et√† > 5 √® ridondante perch√© se l'et√† √® maggiore di 10 √® gi√† maggiore di 5. Inoltre la condizione nome = nome √® sempre vera per tutte le righe. Semplificare la query rimuovendo queste ridondanze migliora chiarezza e prestazioni.",
                "correction": "SELECT * FROM studenti WHERE et√† > 10;"
            },
            "41": {
                "name": "DISTINCT in SUM o AVG",
                "description": "Usare DISTINCT dentro SUM o AVG fa s√¨ che vengano sommati o mediati solo i valori unici, cosa quasi mai voluta.",
                "example": "SELECT AVG(DISTINCT et√†) FROM studenti;",
                "explanation": "Questa query considera prima tutte le et√† uniche degli studenti (ogni valore √® contato una sola volta) e poi calcola la media di quelle et√†. Se ci sono 200 studenti di 20 anni e 1 studente di 30 anni, la media sar√† (20 + 30) / 2 = 25, che non riflette correttamente l'et√† media di tutti gli studenti.",
                "correction": "SELECT AVG(et√†) FROM studenti;"
            },
            "42": {
                "name": "DISTINCT che potrebbe rimuovere duplicati importanti",
                "description": "Usare DISTINCT rimuove le righe duplicate dal risultato, escludendo involontariamente dati importanti.",
                "example": "SELECT DISTINCT nome FROM studenti WHERE grado = 'A';",
                "explanation": "Se pi√π studenti hanno lo stesso nome e hanno ottenuto un voto 'A', usare DISTINCT restituir√† solo una istanza di quel nome, omettendo altri studenti con lo stesso nome che hanno ottenuto 'A'. Questo pu√≤ portare a risultati incompleti o fuorvianti.",
                "correction": "SELECT nome FROM studenti WHERE grado = 'A';"
            },
            "43": {
                "name": "Caratteri jolly senza LIKE",
                "description": "Caratteri jolly come % o _ sono usati con = invece di LIKE, producendo un confronto letterale anzich√© un pattern match.",
                "example": "SELECT * FROM studenti WHERE nome = 'J%n';",
                "explanation": "Questa query seleziona tutti gli studenti il cui nome √® esattamente 'J%n', incluso il simbolo di percentuale, invece di abbinare nomi che iniziano con 'J' e finiscono con 'n' con qualsiasi carattere in mezzo.",
                "correction": "SELECT * FROM studenti WHERE nome LIKE 'J%n';"
            },
            "44": {
                "name": "Carattere jolly errato: uso di _ invece di % o, ad esempio, di *",
                "description": "I caratteri jolly sono usati in modo errato nel pattern matching, come usare _ quando serve % o usare caratteri jolly non standard come *.",
                "example": "SELECT * FROM studenti WHERE nome LIKE 'J*n';",
                "explanation": "La query usa il carattere jolly non standard * invece del carattere jolly SQL standard %. Il carattere * non √® riconosciuto da LIKE per il pattern matching in SQL e viene trattato come carattere letterale.",
                "correction": "SELECT * FROM studenti WHERE nome LIKE 'J%n';"
            },
            "45": {
                "name": "Uso di > 0 con IS NOT NULL o stringa vuota con NULL",
                "description": "Uso di > 0 o = '' per verificare valori non null invece di IS NOT NULL o IS NULL.",
                "example": "SELECT * FROM studenti WHERE punteggio_test = '';",
                "explanation": "Questa query tenta erroneamente di trovare studenti che non hanno sostenuto il test controllando la stringa vuota nella colonna punteggio_test. In realt√† seleziona studenti che hanno sostenuto il test e hanno ricevuto un valore '' (stringa vuota).",
                "correction": "SELECT * FROM studenti WHERE punteggio_test IS NULL;"
            },
            "46": {
                "name": "NULL in sottoquery IN/ANY/ALL",
                "description": "Usare valori annullabili in sottoquery IN, ANY o ALL pu√≤ portare a risultati inattesi a causa della gestione dei NULL in SQL.",
                "example": "SELECT * FROM studenti WHERE et√† IN (SELECT et√† FROM insegnanti);",
                "explanation": "Questa query cerca studenti che hanno la stessa et√† di un insegnante. Tuttavia, se la sottoquery restituisce valori NULL, l'intera condizione IN diventa UNKNOWN per quelle righe, che quindi non verranno incluse nel risultato. Questo pu√≤ portare a dati mancanti se ci sono et√† NULL nella tabella insegnanti.",
                "correction": "SELECT * FROM studenti WHERE et√† IN (SELECT et√† FROM insegnanti WHERE et√† IS NOT NULL);"
            },
            "47": {
                "name": "Join su colonna errata (corrispondenze impossibili)",
                "description": "Viene eseguita una join su colonne che non possono corrispondere logicamente, producendo un risultato vuoto.",
                "example": "SELECT * FROM studenti JOIN insegnanti ON studenti.et√† = insegnanti.stipendio;",
                "explanation": "Questa query prova a unire le tabelle studenti e insegnanti sulla condizione che l'et√† dello studente sia uguale allo stipendio dell'insegnante. Poich√© et√† e stipendio sono dati di natura diversa, la condizione √® illogica e probabilmente non restituir√† righe.",
                "correction": "SELECT * FROM studenti JOIN insegnanti ON studenti.id_classe = insegnanti.id_classe;"
            },
            "48": {
                "name": "Join omessa",
                "description": "Manca o √® incompleta una condizione di join, causando un prodotto cartesiano o risultati errati.",
                "example": "SELECT classe.nome, insegnante.nome FROM classi, insegnanti;",
                "explanation": "Questa query recupera tutte le combinazioni di classi e insegnanti senza specificare come sono correlate. Produce quindi un prodotto cartesiano, dove ogni classe √® abbinata a ogni insegnante, cosa non voluta.",
                "correction": "SELECT classe.nome, insegnante.nome FROM classi, insegnanti WHERE classi.id_insegnante = insegnanti.id;"
            },
            "49": {
                "name": "Molti duplicati",
                "description": "La query restituisce molte volte gli stessi valori, rendendo difficile interpretare i risultati.",
                "example": "SELECT citt√† FROM studenti;",
                "explanation": "Questa query mira a trovare tutte le citt√† in cui vivono gli studenti. Tuttavia, se pi√π studenti vivono nella stessa citt√†, quella citt√† apparir√† pi√π volte nel risultato, generando ridondanza e rendendo pi√π difficile analizzare i dati.",
                "correction": "SELECT DISTINCT citt√† FROM studenti;"
            },
            "50": {
                "name": "Colonna costante in output",
                "description": "Una colonna nell'output ha lo stesso valore costante per tutte le righe.",
                "example": "SELECT nome, paese WHERE paese = 'IT' FROM studenti;",
                "explanation": "La colonna paese non fornisce informazioni utili perch√© ha lo stesso valore ('IT') per tutti gli studenti nel risultato. Questa ridondanza pu√≤ appesantire l'output e distogliere l'attenzione dai dati rilevanti.",
                "correction": "SELECT nome FROM studenti WHERE paese = 'IT';"
            },
            "51": {
                "name": "Colonna duplicata in output",
                "description": "Pi√π colonne nell'output contengono sempre valori identici.",
                "example": "SELECT nome, cognome, nome FROM studenti;",
                "explanation": "La query seleziona due volte la colonna nome, producendo dati duplicati nell'output. Questa ridondanza pu√≤ confondere e rendere pi√π difficile interpretare i risultati.",
                "correction": "SELECT nome, cognome FROM studenti;"
            },
            "52": {
                "name": "OR invece di AND",
                "description": "Una condizione usa OR dove serve AND, producendo risultati pi√π ampi del previsto.",
                "example": "SELECT * FROM studenti WHERE et√† > 18 OR grado = 'A';",
                "explanation": "Questa query dovrebbe trovare gli studenti maggiorenni che hanno preso un voto 'A'. Usando OR restituisce invece tutti gli studenti che sono maggiorenni o che hanno un voto 'A'.",
                "correction": "SELECT * FROM studenti WHERE et√† > 18 AND grado = 'A';"
            },
            "53": {
                "name": "Operatore NOT superfluo",
                "description": "Una condizione usa NOT dove non serve, portando a risultati errati.",
                "example": "SELECT * FROM studenti WHERE et√† > 18 AND NOT grado = 'A';",
                "explanation": "Questa query dovrebbe trovare studenti maggiorenni con voto 'A'. Tuttavia l'operatore NOT nega la condizione sul voto, restituendo studenti maggiorenni che non hanno preso 'A'.",
                "correction": "SELECT * FROM studenti WHERE et√† > 18 AND grado = 'A';"
            },
            "54": {
                "name": "Operatore NOT mancante",
                "description": "Manca un operatore NOT in una condizione, portando a risultati errati.",
                "example": "SELECT * FROM studenti WHERE et√† > 18 AND grado = 'A';",
                "explanation": "Questa query dovrebbe trovare studenti maggiorenni che non hanno preso 'A'. Senza l'operatore NOT restituisce invece studenti che hanno preso 'A'.",
                "correction": "SELECT * FROM studenti WHERE et√† > 18 AND NOT grado = 'A';"
            },
            "55": {
                "name": "Sostituzione della negazione di esistenza con <>",
                "description": "La query usa <> per verificare la non esistenza invece di NOT IN o NOT EXISTS.",
                "example": "SELECT * FROM studenti WHERE id <> (SELECT id_studente FROM laureati);",
                "explanation": "Questa query tenta di trovare gli studenti non laureati usando l'operatore <>. In realt√† restituisce gli studenti il cui id √® diverso dal singolo valore restituito dalla sottoquery, non il comportamento desiderato. Per trovare correttamente gli studenti non laureati, usa NOT IN o NOT EXISTS.",
                "correction": "SELECT * FROM studenti WHERE id NOT IN (SELECT id_studente FROM laureati);"
            },
            "56": {
                "name": "Mettere NOT davanti all'IN/EXISTS sbagliato",
                "description": "Quando si usano pi√π sottoquery IN/EXISTS, NOT viene applicato a quella sbagliata, producendo risultati errati.",
                "example": "SELECT * FROM studenti WHERE id NOT IN (SELECT id_studente FROM laureati) AND id IN (SELECT id_studente FROM iscritti);",
                "explanation": "Questa query vuole trovare studenti iscritti ma non laureati. Tuttavia il NOT √® applicato alla prima sottoquery IN, che verifica i laureati, invece che alla seconda, che verifica gli iscritti. Questo porta a un filtro errato degli studenti.",
                "correction": "SELECT * FROM studenti WHERE id IN (SELECT id_studente FROM iscritti) AND id NOT IN (SELECT id_studente FROM laureati);"
            },
            "57": {
                "name": "Operatore di confronto errato o valore di confronto errato",
                "description": "Una condizione usa l'operatore di confronto sbagliato o confronta con un valore errato, producendo risultati non voluti.",
                "example": "SELECT * FROM studenti WHERE et√† >= 25;",
                "explanation": "Questa query vuole trovare studenti di 18 anni o pi√π. Tuttavia usa il valore d'et√† sbagliato, restituendo solo studenti di almeno 25 anni.",
                "correction": "SELECT * FROM studenti WHERE et√† >= 18;"
            },
            "58": {
                "name": "Join sulla tabella sbagliata",
                "description": "La query fa riferimento alla tabella sbagliata, producendo risultati errati o inattesi.",
                "example": "SELECT nome FROM insegnanti;",
                "explanation": "Questa query vuole recuperare i nomi degli studenti, ma fa riferimento alla tabella insegnanti invece della tabella studenti.",
                "correction": "SELECT nome FROM studenti;"
            },
            "59": {
                "name": "Join quando la join andrebbe omessa",
                "description": "La query fa riferimento a pi√π tabelle del necessario, portando a risultati errati o inattesi.",
                "example": "SELECT nome FROM studenti, insegnanti WHERE ...;",
                "explanation": "Questa query vuole recuperare i nomi degli studenti che soddisfano certi criteri, ma unisce inutilmente la tabella insegnanti, non necessaria a questo scopo. Pu√≤ produrre risultati errati se ci sono pi√π insegnanti associati a uno studente o se non ci sono corrispondenze.",
                "correction": "SELECT nome FROM studenti WHERE ...;"
            },
            "60": {
                "name": "Join su colonna errata (corrispondenze possibili)",
                "description": "Una condizione di join usa la colonna sbagliata, producendo risultati errati o inattesi.",
                "example": "SELECT studenti.nome FROM studenti JOIN insegnanti ON studenti.id_classe = insegnanti.numero_preferito;",
                "explanation": "Questa query vuole recuperare i nomi degli studenti associati a determinati insegnanti. Tuttavia la condizione di join usa la colonna numero_preferito della tabella insegnanti, che non √® logicamente correlata a id_classe degli studenti. Pu√≤ portare a risultati errati perch√© la join pu√≤ abbinare studenti a insegnanti non correlati basandosi su numeri preferiti arbitrari.",
                "correction": "SELECT studenti.nome FROM studenti JOIN insegnanti ON studenti.id_classe = insegnanti.id_classe;"
            },
            "61": {
                "name": "Join con operatore di confronto errato",
                "description": "Una condizione di join usa l'operatore di confronto sbagliato, producendo risultati errati o inattesi.",
                "example": "SELECT studenti.nome FROM studenti JOIN insegnanti ON studenti.id_classe > insegnanti.id_classe;",
                "explanation": "Questa query vuole recuperare i nomi degli studenti associati a specifici insegnanti. Tuttavia la condizione di join usa l'operatore >, che controlla una relazione di maggiore tra studenti.id_classe e insegnanti.id_classe. Non √® il comportamento desiderato, poich√© la join dovrebbe basarsi sull'uguaglianza per associare correttamente studenti e insegnanti.",
                "correction": "SELECT studenti.nome FROM studenti JOIN insegnanti ON studenti.id_classe = insegnanti.id_classe;"
            },
            "62": {
                "name": "Join mancante",
                "description": "La query fa riferimento a meno tabelle del necessario, producendo risultati incompleti.",
                "example": "SELECT studenti.nome FROM studenti WHERE ...;",
                "explanation": "Questa query vuole recuperare i nomi degli studenti associati a specifici insegnanti. Tuttavia non include una join con la tabella insegnanti, necessaria per filtrare gli studenti in base ai loro insegnanti associati. Di conseguenza la query pu√≤ restituire risultati incompleti o non applicare il filtro voluto.",
                "correction": "SELECT studenti.nome FROM studenti, insegnanti WHERE ...;"
            },
            "63": {
                "name": "Annidamento scorretto di espressioni",
                "description": "Le espressioni non sono correttamente annidate con parentesi, portando a un ordine di valutazione errato.",
                "example": "SELECT * FROM studenti WHERE et√† + 5 * 2 > 30;",
                "explanation": "Questa query vuole trovare studenti la cui et√† pi√π 5, moltiplicata per 2, √® maggiore di 30. Senza parentesi, l'operatore di moltiplicazione (*) ha precedenza pi√π alta dell'addizione (+), portando a un ordine di valutazione errato.",
                "correction": "SELECT * FROM studenti WHERE (et√† + 5) * 2 > 30;"
            },
            "64": {
                "name": "Annidamento scorretto di sottoquery",
                "description": "Le sottoquery sono annidate in modo scorretto, portando a un ordine di valutazione diverso da quello previsto.",
                "example": "SELECT * FROM studenti s WHERE id NOT EXISTS (SELECT * FROM laureati g WHERE g.id_studente = s.id AND EXISTS (SELECT * FROM tutor t WHERE t.id_studente = s.id));",
                "explanation": "Questa query vuole trovare studenti che non sono laureati e che hanno tutor. Tuttavia l'annidamento della sottoquery EXISTS dentro la NOT EXISTS restituisce studenti che non sono laureati o che hanno tutor, ma non entrambi.",
                "correction": "SELECT * FROM studenti s WHERE NOT EXISTS (SELECT * FROM laureati g WHERE g.id_studente = s.id) AND EXISTS (SELECT * FROM tutor t WHERE t.id_studente = s.id);"
            },
            "65": {
                "name": "Virgolette superflue",
                "description": "Un nome di colonna √® racchiuso tra virgolette, trasformandolo di fatto in una stringa letterale.",
                "example": "SELECT * FROM studenti WHERE nome = 'nome_supervisore';",
                "explanation": "Questa query vuole trovare studenti che hanno lo stesso nome del loro supervisore. Tuttavia, racchiudendo nome_supervisore tra virgolette, restituisce studenti il cui nome √® letteralmente 'nome_supervisore', invece di confrontarlo con il valore della colonna nome_supervisore.",
                "correction": "SELECT * FROM studenti WHERE nome = nome_supervisore;"
            },
            "66": {
                "name": "Espressione mancante",
                "description": "Nella query manca un'espressione richiesta, causando sintassi incompleta.",
                "example": "SELECT FROM studenti;",
                "explanation": "La clausola SELECT deve specificare almeno una colonna o espressione da restituire. Senza di essa, la query non √® valida.",
                "correction": "SELECT nome FROM studenti;"
            },
            "67": {
                "name": "Espressione sulla colonna sbagliata",
                "description": "Un'espressione viene applicata alla colonna errata, portando a risultati inattesi.",
                "example": "SELECT * FROM studenti WHERE et√† + 5 > 30;",
                "explanation": "La query dovrebbe applicare l'espressione a un'altra colonna (ad esempio anni_di_servizio) ma la applica all'et√†, modificando il filtro rispetto a quanto richiesto.",
                "correction": "SELECT * FROM studenti WHERE anni_di_servizio + 5 > 30;"
            },
            "68": {
                "name": "Espressione superflua",
                "description": "Un'espressione viene aggiunta senza scopo, complicando la query o alterandone i risultati.",
                "example": "SELECT (et√†) AS et√† FROM studenti;",
                "explanation": "Racchiudere et√† tra parentesi e rinominarla con lo stesso nome non aggiunge valore e aumenta inutilmente il rumore nella query.",
                "correction": "SELECT et√† FROM studenti;"
            },
            "69": {
                "name": "Espressione nella clausola errata",
                "description": "Un'espressione compare in una clausola sbagliata, portando a sintassi o logica errata.",
                "example": "SELECT nome FROM studenti GROUP BY et√† + 5;",
                "explanation": "L'espressione et√† + 5 dovrebbe far parte della SELECT o della WHERE; usarla nel GROUP BY cambia l'aggregazione e pu√≤ non essere ci√≤ che l'esercizio richiede.",
                "correction": "SELECT nome, et√† + 5 AS et√†_aumentata FROM studenti;"
            },
            "70": {
                "name": "Colonna superflua in SELECT",
                "description": "Nella clausola SELECT √® inclusa una colonna non prevista o non necessaria per il risultato desiderato.",
                "example": "SELECT nome, et√†, indirizzo FROM studenti;",
                "explanation": "L'esercizio richiede solo nomi ed et√† degli studenti, ma la query include anche la colonna indirizzo nella SELECT. Questo aggiunge dati non necessari al risultato.",
                "correction": "SELECT nome, et√† FROM studenti;"
            },
            "71": {
                "name": "Colonna mancante da SELECT",
                "description": "Manca una colonna richiesta nella clausola SELECT.",
                "example": "SELECT nome FROM studenti;",
                "explanation": "L'esercizio richiede nomi ed et√† degli studenti, ma la query seleziona solo la colonna nome, omettendo la colonna et√†.",
                "correction": "SELECT nome, et√† FROM studenti;"
            },
            "72": {
                "name": "DISTINCT mancante in SELECT",
                "description": "Manca la parola chiave DISTINCT nella clausola SELECT, producendo righe duplicate dove l'esercizio richiede unicit√†.",
                "example": "SELECT citt√† FROM studenti;",
                "explanation": "L'esercizio richiede un elenco di citt√† uniche in cui vivono gli studenti. Tuttavia la query non include DISTINCT, restituendo nomi di citt√† duplicati nell'output.",
                "correction": "SELECT DISTINCT citt√† FROM studenti;"
            },
            "73": {
                "name": "AS mancante in SELECT",
                "description": "Una colonna presenta un nome diverso da quello richiesto dall'esercizio, a causa della mancanza di un alias con AS.",
                "example": "SELECT nome FROM studenti;",
                "explanation": "L'esercizio richiede che la colonna di output sia etichettata come 'nome_studente', ma la query non usa un alias AS per rinominare la colonna.",
                "correction": "SELECT nome AS nome_studente FROM studenti;"
            },
            "74": {
                "name": "Colonna mancante nella clausola ORDER BY",
                "description": "Manca una colonna richiesta nella clausola ORDER BY.",
                "example": "SELECT nome, et√† FROM studenti ORDER BY nome;",
                "explanation": "L'esercizio richiede che i risultati siano ordinati sia per nome che per et√†. Tuttavia la query ordina solo per nome, omettendo et√† dalla clausola ORDER BY.",
                "correction": "SELECT nome, et√† FROM studenti ORDER BY nome, et√†;"
            },
            "75": {
                "name": "Colonna errata nella clausola ORDER BY",
                "description": "Viene usata una colonna errata nella clausola ORDER BY, producendo un ordinamento non voluto.",
                "example": "SELECT nome, et√† FROM studenti ORDER BY citt√†;",
                "explanation": "L'esercizio richiede che i risultati siano ordinati per nome, ma la query ordina per citt√†.",
                "correction": "SELECT nome, et√† FROM studenti ORDER BY nome;"
            },
            "76": {
                "name": "Clausola ORDER BY superflua",
                "description": "Nella query √® presente una clausola ORDER BY anche se l'esercizio non richiede un ordinamento specifico.",
                "example": "SELECT nome, et√† FROM studenti ORDER BY nome;",
                "explanation": "L'esercizio non specifica alcun ordinamento, quindi includere una clausola ORDER BY √® inutile e aggiunge complessit√†.",
                "correction": "SELECT nome, et√† FROM studenti;"
            },
            "77": {
                "name": "Ordinamento errato delle righe",
                "description": "La clausola ORDER BY ordina i risultati nel verso sbagliato (crescente invece di decrescente o viceversa).",
                "example": "SELECT nome, et√† FROM studenti ORDER BY et√† ASC;",
                "explanation": "L'esercizio richiede che i risultati siano ordinati per et√† in ordine decrescente, ma la query ordina in modo crescente.",
                "correction": "SELECT nome, et√† FROM studenti ORDER BY et√† DESC;"
            },
            "78": {
                "name": "DISTINCT come parametro di funzione dove non applicabile",
                "description": "DISTINCT √® usato all'interno di una funzione dove non √® appropriato o necessario.",
                "example": "SELECT COUNT(DISTINCT supervisore) FROM studenti;",
                "explanation": "L'esercizio prevede il numero totale di studenti che hanno un supervisore assegnato, ma DISTINCT fa s√¨ che COUNT conteggi solo i supervisori unici, non √® il comportamento voluto.",
                "correction": "SELECT COUNT(supervisore) FROM studenti;"
            },
            "79": {
                "name": "DISTINCT mancante nel parametro della funzione",
                "description": "DISTINCT manca all'interno di una funzione dove √® necessario per considerare solo valori unici.",
                "example": "SELECT COUNT(supervisore) FROM studenti;",
                "explanation": "L'esercizio richiede di contare il numero di supervisori assegnati agli studenti contando ogni supervisore una sola volta, indipendentemente da quanti studenti supervisiona. Tuttavia la query conta tutte le occorrenze, inclusi i duplicati.",
                "correction": "SELECT COUNT(DISTINCT supervisore) FROM studenti;"
            },
            "80": {
                "name": "Funzione errata",
                "description": "Viene usata la funzione sbagliata per l'operazione desiderata, producendo risultati inattesi.",
                "example": "SELECT SUM(et√†) FROM studenti;",
                "explanation": "L'esercizio richiede di calcolare l'et√† media degli studenti, ma la query usa la funzione SUM invece di AVG, restituendo la somma invece della media.",
                "correction": "SELECT AVG(et√†) FROM studenti;"
            },
            "81": {
                "name": "Colonna errata come parametro di funzione",
                "description": "Viene usata la colonna sbagliata come parametro di una funzione, producendo risultati non voluti.",
                "example": "SELECT EXTRACT(month FROM data_nascita) FROM studenti;",
                "explanation": "L'esercizio chiede il mese di laurea degli studenti, ma la query estrae il mese della loro data di nascita.",
                "correction": "SELECT EXTRACT(month FROM data_laurea) FROM studenti;"
            },
            "82": {
                "name": "Complicazione non necessaria",
                "description": "La query √® pi√π complessa del necessario per ottenere il risultato desiderato.",
                "example": "SELECT nome FROM studenti WHERE et√† > 36 / 2 OR et√† = 9 * (12 - 2);",
                "explanation": "L'esercizio richiede di selezionare studenti di almeno 18 anni. La query usa operazioni aritmetiche superflue per esprimere la condizione, rendendola pi√π complicata del necessario.",
                "correction": "SELECT nome FROM studenti WHERE et√† >= 18;"
            },
            "83": {
                "name": "DISTINCT non necessario nella clausola SELECT",
                "description": "DISTINCT √® usato in una clausola SELECT dove non possono verificarsi duplicati, aggiungendo complessit√† inutile.",
                "example": "SELECT DISTINCT id, nome FROM studenti;",
                "explanation": "La colonna id √® una chiave primaria, quindi ogni valore √® unico. Usare DISTINCT √® ridondante poich√© non possono esistere righe duplicate basate su id.",
                "correction": "SELECT id, nome FROM studenti;"
            },
            "84": {
                "name": "Join non necessaria",
                "description": "Una tabella √® unita solo per accedere a un valore gi√† disponibile come chiave esterna.",
                "example": "SELECT s.id, t.id FROM studenti s JOIN insegnanti t ON s.id_supervisore = t.id;",
                "explanation": "L'esercizio richiede di selezionare gli ID degli studenti insieme ai loro ID di supervisore. La query unisce inutilmente la tabella insegnanti per recuperare gli ID dei supervisori, gi√† disponibili nella tabella studenti come chiavi esterne.",
                "correction": "SELECT id, id_supervisore FROM studenti;"
            },
            "85": {
                "name": "Nome di correlazione inutilizzato",
                "description": "Per una tabella viene definito un nome di correlazione (alias) che non √® poi usato nella query.",
                "example": "SELECT nome FROM studenti s;",
                "explanation": "La query definisce l'alias 's' per la tabella studenti ma non lo usa mai. Aggiunge complessit√† inutile senza benefici.",
                "correction": "SELECT nome FROM studenti;"
            },
            "86": {
                "name": "I nomi di correlazione sono sempre identici",
                "description": "La query fa riferimento a due tabelle che contengono sempre gli stessi dati.",
                "example": "SELECT a.nome, b.nome FROM studenti a JOIN studenti b ON a.id = b.id;",
                "explanation": "La query unisce la tabella studenti con se stessa sulla colonna id, che √® una chiave primaria. Poich√© ogni id √® unico, la join abbiner√† sempre uno studente con se stesso, producendo dati identici da entrambe le tabelle. Questa ridondanza aggiunge complessit√† inutile senza benefici.",
                "correction": "SELECT nome FROM studenti;"
            },
            "86bis": {
                "name": "Nome di correlazione ridondante",
                "description": "La query definisce un alias per una tabella identico al nome originale della tabella, rendendo l'alias ridondante.",
                "example": "SELECT studenti.nome FROM studenti AS studenti studenti;",
                "explanation": "La query definisce l'alias 'studenti' per la tabella studenti, identico al nome originale. Questa ridondanza aggiunge complessit√† inutile senza benefici.",
                "correction": "SELECT studenti.nome FROM studenti;"
            },
            "87": {
                "name": "Operatore di confronto inutilmente generico",
                "description": "Un operatore usato per un confronto pu√≤ essere sostituito da uno pi√π specifico senza cambiare la logica.",
                "example": "SELECT * FROM studenti WHERE et√† >= (SELECT MAX(et√†) FROM studenti);",
                "explanation": "La query vuole trovare gli studenti pi√π anziani. Tuttavia la parte \">\" dell'operatore √® superflua perch√© nessuno studente pu√≤ essere pi√π vecchio del massimo. Usare l'operatore \"=\" rende la query pi√π chiara ed efficiente.",
                "correction": "SELECT * FROM studenti WHERE et√† = (SELECT MAX(et√†) FROM studenti);"
            },
            "88": {
                "name": "LIKE senza caratteri jolly",
                "description": "L'operatore LIKE √® usato senza caratteri jolly, rendendolo equivalente a un semplice confronto di uguaglianza.",
                "example": "SELECT * FROM studenti WHERE nome LIKE 'John';",
                "explanation": "La query usa LIKE per confrontare la colonna nome con 'John' senza caratteri jolly. In questo caso LIKE √® inutile perch√© si comporta come l'operatore =.",
                "correction": "SELECT * FROM studenti WHERE nome = 'John';"
            },
            "89": {
                "name": "SELECT inutilmente complicato in sottoquery EXISTS",
                "description": "La clausola SELECT in una sottoquery EXISTS restituisce pi√π di una colonna, cosa inutile perch√© EXISTS controlla solo l'esistenza di righe.",
                "example": "SELECT nome FROM studenti s WHERE EXISTS (SELECT id, nome FROM insegnanti t WHERE t.nome = s.nome);",
                "explanation": "La sottoquery EXISTS vuole trovare studenti che hanno lo stesso nome di un insegnante. Tuttavia la SELECT nella sottoquery restituisce sia id che nome, cosa inutile perch√© EXISTS controlla solo l'esistenza di righe che soddisfano la condizione. Restituire pi√π colonne aggiunge complessit√† senza benefici.",
                "correction": "SELECT nome FROM studenti s WHERE EXISTS (SELECT 1 FROM insegnanti t WHERE t.nome = s.nome);"
            },
            "90": {
                "name": "IN/EXISTS pu√≤ essere sostituito da un confronto",
                "description": "Una sottoquery che usa IN o EXISTS pu√≤ essere semplificata in un confronto diretto.",
                "example": "SELECT * FROM studenti WHERE id NOT IN (SELECT id FROM studenti WHERE et√† < 18);",
                "explanation": "La query trova studenti di almeno 18 anni selezionando quelli il cui ID non √® nell'insieme di ID degli studenti pi√π giovani di 18 anni. Pu√≤ essere semplificata controllando direttamente l'et√†, soluzione pi√π chiara ed efficiente.",
                "correction": "SELECT * FROM studenti WHERE et√† >= 18;"
            },
            "91": {
                "name": "Funzione di aggregazione non necessaria",
                "description": "Viene usata una funzione di aggregazione su un singolo valore.",
                "example": "SELECT MAX(et√†) FROM studenti WHERE id = 123;",
                "explanation": "La query recupera l'et√† di uno specifico studente con id 123. Poich√© la clausola WHERE filtra a una sola riga, usare la funzione di aggregazione MAX √® inutile: c'√® solo un valore da restituire.",
                "correction": "SELECT et√† FROM studenti WHERE id = 123;"
            },
            "92": {
                "name": "DISTINCT non necessario nella funzione di aggregazione",
                "description": "DISTINCT √® usato all'interno di una funzione di aggregazione dove tutti i valori sono gi√† unici, rendendolo ridondante.",
                "example": "SELECT COUNT(DISTINCT id) FROM studenti;",
                "explanation": "La colonna id √® una chiave primaria, quindi ogni valore √® unico. Usare DISTINCT dentro COUNT non cambia il risultato, perch√© non ci sono duplicati da contare.",
                "correction": "SELECT COUNT(id) FROM studenti;"
            },
            "93": {
                "name": "Argomento non necessario per COUNT",
                "description": "COUNT viene usato con un nome di colonna specifico invece di COUNT(*) o COUNT(1) quando si contano colonne non nullabili.",
                "example": "SELECT COUNT(nome) FROM studenti;",
                "explanation": "La colonna nome √® definita NOT NULL, quindi non pu√≤ contenere valori NULL. Di conseguenza COUNT(nome) equivale a COUNT(*), poich√© tutte le righe verranno contate. In questo caso usare COUNT(*) √® pi√π semplice ed efficiente.",
                "correction": "SELECT COUNT(*) FROM studenti;"
            },
            "94": {
                "name": "GROUP BY non necessario in sottoquery EXISTS",
                "description": "In una sottoquery EXISTS viene usata una clausola GROUP BY non necessaria, dato che EXISTS verifica solo l'esistenza di righe.",
                "example": "SELECT nome FROM studenti s WHERE EXISTS (SELECT 1 FROM insegnanti t GROUP BY t.nome HAVING t.nome = s.nome);",
                "explanation": "La sottoquery EXISTS vuole trovare studenti che hanno lo stesso nome di un insegnante. Tuttavia la clausola GROUP BY √® inutile perch√© EXISTS verifica solo l'esistenza di righe che soddisfano la condizione. Usare GROUP BY aggiunge complessit√† senza benefici.",
                "correction": "SELECT nome FROM studenti s WHERE EXISTS (SELECT 1 FROM insegnanti t WHERE t.nome = s.nome);"
            },
            "95": {
                "name": "GROUP BY con gruppi singoletti",
                "description": "GROUP BY √® usato su gruppi che contengono una sola riga ciascuno, rendendo il raggruppamento inutile.",
                "example": "SELECT id, AVG(et√†) FROM studenti GROUP BY id;",
                "explanation": "La query raggruppa gli studenti per id, che √® una chiave primaria. Poich√© ogni id √® unico, ogni gruppo avr√† una sola riga. Usare GROUP BY √® quindi inutile perch√© non cambia il risultato.",
                "correction": "SELECT id, et√† FROM studenti;"
            },
            "96": {
                "name": "GROUP BY con un solo gruppo",
                "description": "GROUP BY √® usato in modo tale da produrre un solo gruppo, rendendo il raggruppamento inutile.",
                "example": "SELECT AVG(et√†) FROM studenti WHERE paese = 'IT' GROUP BY paese;",
                "explanation": "La query raggruppa gli studenti per paese dopo aver filtrato quelli in 'IT'. Poich√© tutte le righe rimanenti appartengono allo stesso paese, c'√® un solo gruppo. Usare GROUP BY √® quindi inutile perch√© non cambia il risultato.",
                "correction": "SELECT AVG(et√†) FROM studenti WHERE paese = 'IT';"
            },
            "97": {
                "name": "GROUP BY pu√≤ essere sostituito da DISTINCT",
                "description": "Tutte le colonne del GROUP BY sono anche nella clausola SELECT senza funzioni di aggregazione, rendendo DISTINCT un'alternativa pi√π semplice.",
                "example": "SELECT nome, et√† FROM studenti GROUP BY nome, et√†;",
                "explanation": "La query raggruppa gli studenti per nome ed et√† ma non usa funzioni di aggregazione. Poich√© la SELECT contiene solo le colonne di raggruppamento, usare DISTINCT √® pi√π semplice ed efficiente per ottenere lo stesso risultato.",
                "correction": "SELECT DISTINCT nome, et√† FROM studenti;"
            },
            "98": {
                "name": "UNION pu√≤ essere sostituito da OR",
                "description": "Due istruzioni SELECT combinate con UNION possono essere semplificate in una sola SELECT con una condizione OR.",
                "example": "SELECT nome FROM studenti WHERE et√† < 18 UNION SELECT nome FROM studenti WHERE grado = 'A';",
                "explanation": "La query recupera i nomi degli studenti che sono minori di 18 anni o che hanno ottenuto un voto 'A'. Pu√≤ essere semplificata usando una singola SELECT con una condizione OR nella clausola WHERE, soluzione pi√π diretta ed efficiente.",
                "correction": "SELECT nome FROM studenti WHERE et√† < 18 OR grado = 'A';"
            },
            "99": {
                "name": "Colonna non necessaria nella clausola ORDER BY",
                "description": "Nella clausola ORDER BY √® inclusa una colonna che non influisce sull'ordinamento dei risultati a causa di dipendenze funzionali.",
                "example": "SELECT id, nome FROM studenti ORDER BY id, nome;",
                "explanation": "La query ordina i risultati per id e poi per nome. Tuttavia id √® una chiave primaria, quindi identifica univocamente ogni riga. Ordinare per nome dopo id non cambia l'ordine, rendendolo superfluo.",
                "correction": "SELECT id, nome FROM studenti ORDER BY id;"
            },
            "100": {
                "name": "ORDER BY in sottoquery",
                "description": "Viene usata una clausola ORDER BY in una sottoquery dove non influisce sul risultato finale.",
                "example": "SELECT nome FROM studenti WHERE nome IN (SELECT nome FROM insegnanti ORDER BY nome);",
                "explanation": "La query recupera i nomi degli studenti che hanno lo stesso nome di un insegnante. Tuttavia la clausola ORDER BY nella sottoquery √® inutile, poich√© l'ordine delle righe in una sottoquery non influisce sul risultato finale della query esterna.",
                "correction": "SELECT nome FROM studenti WHERE nome IN (SELECT nome FROM insegnanti);"
            },
            "101": {
                "name": "HAVING inefficiente",
                "description": "Una condizione nella clausola HAVING non dipende da funzioni di aggregazione e pu√≤ essere spostata nella clausola WHERE.",
                "example": "SELECT supervisore, COUNT(*) FROM studenti GROUP BY supervisore HAVING supervisore IS NOT NULL;",
                "explanation": "La clausola HAVING viene usata per filtrare gruppi in base a condizioni di aggregazione. Tuttavia la condizione 'supervisore IS NOT NULL' non dipende da funzioni di aggregazione e pu√≤ essere applicata prima del raggruppamento. Spostarla nella clausola WHERE migliora l'efficienza riducendo le righe da raggruppare.",
                "correction": "SELECT supervisore, COUNT(*) FROM studenti WHERE supervisore IS NOT NULL GROUP BY supervisore;"
            },
            "102": {
                "name": "UNION inefficiente",
                "description": "Un'operazione UNION pu√≤ essere sostituita da UNION ALL senza cambiare il risultato, migliorando le prestazioni.",
                "example": "SELECT nome FROM studenti WHERE et√† < 18 UNION SELECT nome FROM studenti WHERE et√† > 30;",
                "explanation": "Le due query recuperano i nomi degli studenti da gruppi di et√† disgiunti (meno di 18 e pi√π di 30). Poich√© non c'√® sovrapposizione, usare UNION ALL √® pi√π efficiente perch√© non esegue il passaggio aggiuntivo di rimuovere i duplicati, inutile in questo caso.",
                "correction": "SELECT nome FROM studenti WHERE et√† < 18 UNION ALL SELECT nome FROM studenti WHERE et√† > 30;"
            },
            "103": {
                "name": "La condizione nella sottoquery pu√≤ essere spostata in alto",
                "description": "Una condizione nella sottoquery fa riferimento solo a valori della query esterna e pu√≤ essere spostata nella clausola WHERE esterna.",
                "example": "SELECT nome FROM studenti s WHERE EXISTS (SELECT 1 FROM insegnanti t WHERE t.nome = s.nome AND s.et√† > 18);",
                "explanation": "La condizione 's.et√† > 18' nella sottoquery fa riferimento solo alla tabella esterna 'studenti'. Pu√≤ quindi essere spostata nella clausola WHERE esterna, migliorando la leggibilit√† e potenzialmente le prestazioni.",
                "correction": "SELECT nome FROM studenti s WHERE s.et√† > 18 AND EXISTS (SELECT 1 FROM insegnanti t WHERE t.nome = s.nome);"
            },
            "104": {
                "name": "Condizione sulla tabella di sinistra in LEFT OUTER JOIN",
                "description": "Usare una condizione di JOIN ON sulla tabella di sinistra di un LEFT OUTER JOIN influisce solo sulla tabella di destra e pu√≤ portare a risultati inattesi.",
                "example": "SELECT s.nome, t.nome FROM studenti s LEFT OUTER JOIN insegnanti t ON s.id_supervisore = t.id AND s.et√† > 18;",
                "explanation": "La condizione 's.et√† > 18' √® applicata solo alla tabella di destra. Se uno studente ha meno di 18 anni, la join includer√† comunque lo studente con valori NULL per le colonne dell'insegnante, cosa non desiderata. Per filtrare gli studenti in base all'et√†, la condizione dovrebbe essere nella clausola WHERE.",
                "correction": "SELECT s.nome, t.nome FROM studenti s LEFT OUTER JOIN insegnanti t ON s.id_supervisore = t.id WHERE s.et√† > 18;"
            },
            "105": {
                "name": "OUTER JOIN pu√≤ essere sostituito da INNER JOIN",
                "description": "Usare una condizione WHERE sulla tabella di destra di un LEFT OUTER JOIN di fatto lo trasforma in un INNER JOIN.",
                "example": "SELECT s.nome, t.nome FROM studenti s LEFT OUTER JOIN insegnanti t ON s.id_supervisore = t.id WHERE t.dipartimento = 'Matematica';",
                "explanation": "La condizione WHERE 't.dipartimento = 'Matematica'' esclude le righe senza insegnante corrispondente, annullando lo scopo del LEFT OUTER JOIN. In questo caso un INNER JOIN √® pi√π appropriato ed efficiente.",
                "correction": "SELECT s.nome, t.nome FROM studenti s INNER JOIN insegnanti t ON s.id_supervisore = t.id WHERE t.dipartimento = 'Matematica';"
            }
        }
    }
}
